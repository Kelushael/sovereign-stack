#!/usr/bin/env python3
"""
axis - Sovereign AI CLI
One shot terminal. Same memory. Slash commands everywhere.

Usage:
  axis                          # Interactive chat
  axis "ask anything"           # One-shot query
  axis --scrape URL [FOLDER]    # Scrape URL
  axis --help                   # Help

Slash commands (in chat or one-shot):
  /scrape <url> [folder]        # Scrape a URL
  /search <query>               # Web search
  /run <command>                # Run shell command
  /read <file>                  # Read file into context
  /save [file]                  # Save last response
  /clear                        # Clear memory
  /history                      # Show session history
  /models                       # List available models
  /model <name>                 # Switch model
  /help                         # Show all commands
"""

import os, sys, json, time, uuid, re, subprocess, shutil
import urllib.request, urllib.parse
from pathlib import Path
from textwrap import fill

# â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AMALLO_URL   = os.environ.get('AMALLO_URL', 'https://axismundi.fun')
KEY_FILE     = Path.home() / '.config/amallo/key'
HISTORY_FILE = Path.home() / '.local/share/amallo/axis-history.jsonl'
SESSION_FILE = Path.home() / '.local/share/amallo/axis-session.json'
MODEL        = os.environ.get('AXIS_MODEL', 'dolphin-mistral:latest')

MODEL_ALIASES = {
    'dolphin':    'dolphin-mistral:latest',
    'mistral':    'dolphin-mistral:latest',
    'glm':        'glm4:latest',
    'glm4':       'glm4:latest',
    'default':    'dolphin-mistral:latest',
    # diffusion paradigm
    'diffusion':  'GSAI-ML/LLaDA-8B-Instruct',
    'llada':      'GSAI-ML/LLaDA-8B-Instruct',
    'llada2':     'inclusionAI/LLaDA2.1-mini',
    # brain router â€” use this to auto-route across all paradigms
    'brain':      'brain',
    'auto':       'brain',
}
# Brain router runs locally on port 8100 â€” overrides AMALLO_URL when model=brain
BRAIN_URL = os.environ.get('BRAIN_URL', 'http://localhost:8100')
DIFFUSION_URL = os.environ.get('DIFFUSION_URL', 'http://localhost:8200')
VERSION      = '1.0.0'
MAX_CONTEXT  = 12  # messages to keep in memory

# â”€â”€ COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class C:
    RESET  = '\033[0m'
    BOLD   = '\033[1m'
    DIM    = '\033[2m'
    GREEN  = '\033[0;32m'
    BLUE   = '\033[0;34m'
    PURPLE = '\033[0;35m'
    CYAN   = '\033[0;36m'
    ORANGE = '\033[0;33m'
    RED    = '\033[0;31m'
    GRAY   = '\033[0;90m'

def c(color, text): return f"{color}{text}{C.RESET}"
def ok(msg):  print(c(C.GREEN,  f"âœ“ {msg}"))
def err(msg): print(c(C.RED,    f"âœ— {msg}"), file=sys.stderr)
def info(msg): print(c(C.CYAN,  f"  {msg}"))
def dim(msg): print(c(C.DIM,    f"  {msg}"))

# â”€â”€ API KEY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_key():
    if KEY_FILE.exists():
        return KEY_FILE.read_text().strip()
    # Auto-create key
    print(c(C.ORANGE, "No API key found. Creating one..."))
    try:
        data = json.dumps({'identity': os.environ.get('USER','user'), 'role':'user'}).encode()
        req = urllib.request.Request(f'{AMALLO_URL}/amallo/keys/create', data=data,
                                     headers={'Content-Type':'application/json'})
        with urllib.request.urlopen(req, timeout=10) as r:
            resp = json.loads(r.read())
            key = resp['key']
            KEY_FILE.parent.mkdir(parents=True, exist_ok=True)
            KEY_FILE.write_text(key)
            KEY_FILE.chmod(0o600)
            ok(f"Created key: {key}")
            return key
    except Exception as e:
        err(f"Could not create key: {e}")
        sys.exit(1)

# â”€â”€ MEMORY / SESSION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_session():
    if SESSION_FILE.exists():
        try:
            return json.loads(SESSION_FILE.read_text())
        except:
            pass
    return {'messages': [], 'model': MODEL, 'id': uuid.uuid4().hex[:8]}

def save_session(session):
    SESSION_FILE.parent.mkdir(parents=True, exist_ok=True)
    SESSION_FILE.write_text(json.dumps(session))

def log_history(role, content):
    HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(HISTORY_FILE, 'a') as f:
        f.write(json.dumps({'ts': int(time.time()), 'role': role, 'content': content}) + '\n')

def trim_context(messages):
    # Keep system message + last N messages
    sys_msgs = [m for m in messages if m.get('role') == 'system']
    other    = [m for m in messages if m.get('role') != 'system']
    return sys_msgs + other[-MAX_CONTEXT:]

# â”€â”€ AI CALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def ask_ai(messages, model=None, max_tokens=1024):
    key = get_key()
    mdl = model or MODEL
    mdl = MODEL_ALIASES.get(mdl, mdl)  # resolve alias

    # Route to correct backend based on model
    if mdl in ('brain',):
        endpoint = f'{BRAIN_URL}/v1/chat/completions'
    elif mdl.startswith('GSAI-ML/') or mdl.startswith('inclusionAI/LLaDA'):
        endpoint = f'{DIFFUSION_URL}/v1/chat/completions'
    else:
        endpoint = f'{AMALLO_URL}/v1/chat/completions'

    try:
        data = json.dumps({
            'model': mdl,
            'messages': messages,
            'max_tokens': max_tokens,
            'temperature': 0.7
        }).encode()
        req = urllib.request.Request(
            endpoint, data=data,
            headers={'Authorization': f'Bearer {key}', 'Content-Type': 'application/json'})
        with urllib.request.urlopen(req, timeout=60) as r:
            resp = json.loads(r.read())
            content = resp['choices'][0]['message']['content']
            # Clean artifacts + Amallo-specific noise
            content = re.sub(r'<\|end of response\|>', '', content)
            content = re.sub(r'\[No inference backend available.*?\]', '[Amallo: model not loaded]', content)
            return content.strip()
    except urllib.error.URLError:
        err("Cannot reach Amallo. Check connection or run local server.")
        sys.exit(1)
    except Exception as e:
        err(f"API error: {e}")
        return None

# â”€â”€ SCRAPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def scrape(url, folder=None, session=None):
    print(c(C.CYAN, f"ðŸ•·  Scraping: {url}"))

    # Fetch raw content
    try:
        req = urllib.request.Request(url, headers={
            'User-Agent': 'Mozilla/5.0 (axis/1.0; sovereign-scraper)'
        })
        with urllib.request.urlopen(req, timeout=30) as r:
            raw = r.read()
            content_type = r.headers.get('Content-Type','')
    except Exception as e:
        err(f"Fetch failed: {e}")
        return None

    # Extract text
    try:
        html = raw.decode('utf-8', errors='ignore')
    except:
        html = raw.decode('latin-1', errors='ignore')

    # Strip HTML tags â†’ clean text
    text = re.sub(r'<script[^>]*>.*?</script>', '', html, flags=re.DOTALL|re.IGNORECASE)
    text = re.sub(r'<style[^>]*>.*?</style>',  '', text,  flags=re.DOTALL|re.IGNORECASE)
    text = re.sub(r'<[^>]+>', ' ', text)
    text = re.sub(r'&nbsp;', ' ', text)
    text = re.sub(r'&amp;',  '&', text)
    text = re.sub(r'&lt;',   '<', text)
    text = re.sub(r'&gt;',   '>', text)
    text = re.sub(r'\s+',    ' ', text).strip()

    # Get title
    title_match = re.search(r'<title[^>]*>(.*?)</title>', html, re.IGNORECASE|re.DOTALL)
    title = re.sub(r'\s+', ' ', title_match.group(1)).strip() if title_match else url

    ok(f"Fetched: {title[:60]}")
    info(f"Content: {len(text):,} chars")

    # Save to folder
    saved_path = None
    if folder:
        dest = Path(folder)
        dest.mkdir(parents=True, exist_ok=True)
        # Sanitize filename from URL
        slug = re.sub(r'[^a-zA-Z0-9]+', '-', urllib.parse.urlparse(url).path)
        slug = slug.strip('-') or 'index'
        ts   = int(time.time())
        # Save raw HTML
        html_file = dest / f"{slug}-{ts}.html"
        html_file.write_text(html)
        # Save clean text
        txt_file = dest / f"{slug}-{ts}.txt"
        txt_file.write_text(f"URL: {url}\nTitle: {title}\n\n{text}")
        saved_path = str(txt_file)
        ok(f"Saved: {txt_file}")
        ok(f"HTML:  {html_file}")

    # AI summary
    print(c(C.BLUE, "\nðŸ“‹ Summarizing..."))
    preview = text[:3000]
    msgs = [{
        'role': 'user',
        'content': f'Summarize this webpage content concisely. URL: {url}\nTitle: {title}\n\nContent:\n{preview}'
    }]
    summary = ask_ai(msgs, max_tokens=400)
    if summary:
        print()
        print(c(C.BOLD, "Summary:"))
        for line in summary.split('\n'):
            print(f"  {line}")

    # Add to session context
    if session is not None:
        context_snippet = text[:2000]
        session['messages'].append({
            'role': 'user',
            'content': f'[Scraped {url}]\n{context_snippet}'
        })
        session['messages'].append({
            'role': 'assistant',
            'content': summary or 'Scraped content added to context.'
        })
        session['messages'] = trim_context(session['messages'])
        save_session(session)
        dim("(Content added to chat memory - you can now ask questions about it)")

    return summary

# â”€â”€ SLASH COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS = {}

def command(name, aliases=(), usage='', desc=''):
    def decorator(fn):
        COMMANDS[name] = {'fn': fn, 'usage': usage, 'desc': desc}
        for a in aliases:
            COMMANDS[a] = COMMANDS[name]
        return fn
    return decorator

@command('/scrape', aliases=('/sc',),
         usage='/scrape <url> [folder]',
         desc='Scrape a URL, summarize it, save to folder, add to memory')
def cmd_scrape(args, session):
    parts = args.strip().split()
    if not parts:
        url = input(c(C.ORANGE, "URL to scrape: ")).strip()
        if not url: return "Cancelled."
        parts = [url]
    url = parts[0]
    if not url.startswith('http'):
        url = 'https://' + url
    folder = parts[1] if len(parts) > 1 else None
    scrape(url, folder, session)

@command('/run', aliases=('/!', '/exec'),
         usage='/run <bash command>',
         desc='Run a shell command and add output to context')
def cmd_run(args, session):
    if not args.strip():
        args = input(c(C.ORANGE, "Command to run: ")).strip()
    print(c(C.DIM, f"$ {args}"))
    try:
        result = subprocess.run(args, shell=True, capture_output=True, text=True, timeout=30)
        output = (result.stdout + result.stderr).strip()
        print(output)
        # Add to context
        session['messages'].append({'role':'user',    'content': f'[Command: {args}]\n{output}'})
        session['messages'].append({'role':'assistant','content': 'Command output added to context.'})
        session['messages'] = trim_context(session['messages'])
        save_session(session)
    except Exception as e:
        err(str(e))

@command('/read', aliases=('/r',),
         usage='/read <file>',
         desc='Read a file and add its content to memory')
def cmd_read(args, session):
    path = args.strip()
    if not path:
        path = input(c(C.ORANGE, "File to read: ")).strip()
    try:
        content = Path(path).read_text()
        info(f"Read {len(content):,} chars from {path}")
        session['messages'].append({'role':'user',     'content': f'[File: {path}]\n{content[:4000]}'})
        session['messages'].append({'role':'assistant','content': f'File {path} loaded into context.'})
        session['messages'] = trim_context(session['messages'])
        save_session(session)
        ok("Added to memory")
    except Exception as e:
        err(str(e))

@command('/save', aliases=('/s',),
         usage='/save [filename]',
         desc='Save last AI response to a file')
def cmd_save(args, session):
    msgs = [m for m in session['messages'] if m['role'] == 'assistant']
    if not msgs:
        err("No AI response to save yet.")
        return
    content = msgs[-1]['content']
    path = args.strip() or f"axis-save-{int(time.time())}.txt"
    Path(path).write_text(content)
    ok(f"Saved to {path}")

@command('/model', aliases=('/m',),
         usage='/model <name>',
         desc='Switch AI model (qwen, glm4, dolphin, nano)')
def cmd_model(args, session):
    global MODEL
    name = args.strip()
    if not name:
        print(c(C.BOLD, f"Current model: {session.get('model', MODEL)}"))
        # List available
        key = get_key()
        req = urllib.request.Request(f'{AMALLO_URL}/v1/models',
                                     headers={'Authorization': f'Bearer {key}'})
        with urllib.request.urlopen(req, timeout=10) as r:
            models = json.loads(r.read())
            print(c(C.BOLD, "Available:"))
            for m in models.get('data', []):
                print(f"  â€¢ {m['id']}")
        return
    session['model'] = name
    MODEL = name
    save_session(session)
    ok(f"Switched to: {name}")

@command('/models', aliases=(),
         usage='/models',
         desc='List available models')
def cmd_models(args, session):
    cmd_model('', session)

@command('/chain', aliases=('/c',),
         usage='/chain',
         desc='Toggle chain mode: auto-run code from each AI response')
def cmd_chain(args, session):
    session['chain'] = not session.get('chain', False)
    state = session['chain']
    save_session(session)
    if state:
        print(c(C.PURPLE, "  â›“  CHAIN ON"))
        print(c(C.DIM,    "  On each response:"))
        print(c(C.DIM,    "    1. double Enter (clears any y/n gate)"))
        print(c(C.DIM,    "    2. extract code from response"))
        print(c(C.DIM,    "    3. paste + run it"))
        print(c(C.DIM,    "  /chain again or Ctrl+C to stop"))
    else:
        print(c(C.DIM, "  â›“  CHAIN OFF"))

@command('/clear', aliases=('/reset',),
         usage='/clear',
         desc='Clear conversation memory (start fresh)')
def cmd_clear(args, session):
    session['messages'] = []
    save_session(session)
    ok("Memory cleared")

@command('/history', aliases=('/h',),
         usage='/history [n]',
         desc='Show conversation history')
def cmd_history(args, session):
    n = int(args.strip()) if args.strip().isdigit() else 10
    msgs = session['messages'][-n:]
    if not msgs:
        dim("No history yet.")
        return
    for m in msgs:
        role = m['role']
        content = m['content'][:100] + '...' if len(m['content']) > 100 else m['content']
        color = C.GREEN if role == 'user' else C.BLUE
        print(c(color, f"{role}: ") + content)

@command('/help', aliases=('/?', '/commands'),
         usage='/help',
         desc='Show all commands')
def cmd_help(args, session):
    print()
    print(c(C.BOLD + C.PURPLE, "  axis commands"))
    print(c(C.DIM, "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))
    seen = set()
    for name, cmd in COMMANDS.items():
        if cmd['fn'] in seen: continue
        seen.add(cmd['fn'])
        print(f"  {c(C.CYAN, cmd['usage'].ljust(28))} {cmd['desc']}")
    print()
    print(c(C.DIM, "  Or just type anything â€” axis will figure it out."))
    print()

# â”€â”€ DISPATCH SLASH COMMAND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def dispatch(text, session):
    """Handle slash command or pass to AI."""
    text = text.strip()
    if not text: return

    # Parse slash command
    if text.startswith('/'):
        parts = text.split(None, 1)
        name  = parts[0].lower()
        args  = parts[1] if len(parts) > 1 else ''

        if name in COMMANDS:
            return COMMANDS[name]['fn'](args, session)
        else:
            # Unknown command - let AI figure it out
            print(c(C.DIM, f"Unknown command '{name}'. Asking AI..."))
            intent_msg = [{
                'role': 'system',
                'content': (
                    'You are axis, a sovereign AI CLI. The user typed an unknown slash command. '
                    'Try to understand what they want and do it, or ask them one clarifying question.'
                )
            }, {'role': 'user', 'content': text}]
            reply = ask_ai(intent_msg, max_tokens=300)
            if reply:
                print()
                print_response(reply)
                session['messages'].append({'role':'user',      'content': text})
                session['messages'].append({'role':'assistant', 'content': reply})
                save_session(session)
            return

    # Regular message - send to AI
    session['messages'].append({'role': 'user', 'content': text})
    session['messages'] = trim_context(session['messages'])
    log_history('user', text)

    print(c(C.DIM, "..."), end='\r')
    reply = ask_ai(session['messages'], model=session.get('model', MODEL))

    if reply:
        print(' ' * 10, end='\r')
        print()
        print_response(reply)
        print()
        session['messages'].append({'role': 'assistant', 'content': reply})
        session['messages'] = trim_context(session['messages'])
        log_history('assistant', reply)
        save_session(session)
        return reply   # caller (repl) uses this for chain mode

def print_response(text):
    """Pretty-print AI response."""
    width = min(shutil.get_terminal_size().columns - 4, 80)
    for line in text.split('\n'):
        if line.startswith('```'):
            print(c(C.DIM, '  ' + line))
        elif line.startswith('#'):
            print(c(C.BOLD, '  ' + line))
        elif line.startswith('- ') or line.startswith('* '):
            print(c(C.CYAN, '  â€¢') + ' ' + line[2:])
        else:
            if len(line) > width:
                wrapped = fill(line, width=width)
                for wl in wrapped.split('\n'):
                    print('  ' + wl)
            else:
                print('  ' + line)

def extract_code(text):
    """Pull the first code block out of a response, or return full text."""
    # fenced code block: ```lang\n...code...\n```
    m = re.search(r'```(?:\w+)?\n?([\s\S]*?)```', text)
    if m:
        return m.group(1).strip()
    # single backtick inline and barely any other text
    m = re.search(r'`([^`]+)`', text)
    if m and len(re.sub(r'`[^`]+`', '', text).strip()) < 20:
        return m.group(1).strip()
    return text.strip()

# â”€â”€ INTERACTIVE CHAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def repl(session):
    """Interactive chat mode."""
    model = session.get('model', MODEL)
    print(c(C.PURPLE, f"\n  axis {VERSION}  ") + c(C.DIM, f"model:{model}  /help for commands"))
    print(c(C.DIM, "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))
    print()

    while True:
        try:
            text = input(c(C.GREEN, 'you > ')).strip()
            if not text: continue
            if text.lower() in ('exit', 'quit', 'bye', '/exit', '/quit'):
                print(c(C.DIM, "  bye"))
                break

            reply = dispatch(text, session)

            # â”€â”€ CHAIN MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # After every AI response, if chain is ON:
            #   step 1: double Enter (y) â€” clears any y/n gate silently
            #   step 2: extract code from response
            #   step 3: paste it back as next input and run it
            while reply and session.get('chain'):
                code = extract_code(reply)
                # step 1: two silent 'y' dispatches for confirmation gates
                dispatch('y', session)
                dispatch('y', session)
                # step 2+3: run the extracted code as next prompt
                print(c(C.PURPLE, f"  â›“  chaining: ") + c(C.DIM, code[:80]))
                reply = dispatch(code, session)

        except KeyboardInterrupt:
            print()
            if session.get('chain'):
                session['chain'] = False
                save_session(session)
                print(c(C.DIM, "  â›“  chain stopped"))
            else:
                print(c(C.DIM, "  (Ctrl+C â€” type 'exit' to quit)"))
        except EOFError:
            print()
            break

# â”€â”€ ENTRY POINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    args = sys.argv[1:]
    session = load_session()

    # No args â†’ interactive
    if not args:
        repl(session)
        return

    # Parse --flags
    if args[0] in ('--help', '-h'):
        print(__doc__)
        return

    if args[0] in ('--version', '-v'):
        print(f"axis {VERSION}")
        return

    if args[0] in ('--scrape', '--amalloscrape'):
        url    = args[1] if len(args) > 1 else input("URL: ").strip()
        folder = args[2] if len(args) > 2 else None
        if not url.startswith('http'): url = 'https://' + url
        scrape(url, folder, session)
        return

    if args[0] == '--clear':
        session['messages'] = []
        save_session(session)
        ok("Memory cleared")
        return

    if args[0] == '--history':
        n = int(args[1]) if len(args) > 1 else 10
        cmd_history(str(n), session)
        return

    if args[0] == '--model':
        if len(args) > 1:
            cmd_model(args[1], session)
        else:
            cmd_model('', session)
        return

    # Everything else: one-shot query or slash command
    text = ' '.join(args)

    # Check if it looks like a question/task
    if not text.startswith('/') and not text.startswith('--'):
        # One-shot query
        session['messages'].append({'role': 'user', 'content': text})
        session['messages'] = trim_context(session['messages'])
        log_history('user', text)

        reply = ask_ai(session['messages'], model=session.get('model', MODEL))
        if reply:
            print_response(reply)
            print()
            session['messages'].append({'role': 'assistant', 'content': reply})
            save_session(session)
    else:
        dispatch(text, session)

if __name__ == '__main__':
    main()
