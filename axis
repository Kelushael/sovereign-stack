#!/usr/bin/env python3
"""
axis - Sovereign AI CLI
One shot terminal. Same memory. Slash commands everywhere.

Usage:
  axis                          # Interactive chat
  axis "ask anything"           # One-shot query
  axis --scrape URL [FOLDER]    # Scrape URL
  axis --help                   # Help

Slash commands (in chat or one-shot):
  /scrape <url> [folder]        # Scrape a URL
  /search <query>               # Web search
  /run <command>                # Run shell command
  /read <file>                  # Read file into context
  /save [file]                  # Save last response
  /clear                        # Clear memory
  /history                      # Show session history
  /models                       # List available models
  /model <name>                 # Switch model
  /help                         # Show all commands
"""

import os, sys, json, time, uuid, re, subprocess, shutil
import urllib.request, urllib.parse
from pathlib import Path
from textwrap import fill

# â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AMALLO_URL   = os.environ.get('AMALLO_URL', 'https://axismundi.fun')
KEY_FILE     = Path.home() / '.config/amallo/key'
HISTORY_FILE = Path.home() / '.local/share/amallo/axis-history.jsonl'
SESSION_FILE = Path.home() / '.local/share/amallo/axis-session.json'
MODEL        = os.environ.get('AXIS_MODEL', 'dolphin-mistral:latest')

MODEL_ALIASES = {
    'dolphin':    'dolphin-mistral:latest',
    'mistral':    'dolphin-mistral:latest',
    'glm':        'glm4:latest',
    'glm4':       'glm4:latest',
    'default':    'dolphin-mistral:latest',
    # diffusion paradigm
    'diffusion':  'GSAI-ML/LLaDA-8B-Instruct',
    'llada':      'GSAI-ML/LLaDA-8B-Instruct',
    'llada2':     'inclusionAI/LLaDA2.1-mini',
    # brain router â€” use this to auto-route across all paradigms
    'brain':      'brain',
    'auto':       'brain',
}
# Brain router runs locally on port 8100 â€” overrides AMALLO_URL when model=brain
BRAIN_URL = os.environ.get('BRAIN_URL', 'http://localhost:8100')
DIFFUSION_URL = os.environ.get('DIFFUSION_URL', 'http://localhost:8200')
VERSION      = '1.0.0'
MAX_CONTEXT  = 12  # messages to keep in memory

# â”€â”€ COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class C:
    RESET  = '\033[0m'
    BOLD   = '\033[1m'
    DIM    = '\033[2m'
    GREEN  = '\033[0;32m'
    BLUE   = '\033[0;34m'
    PURPLE = '\033[0;35m'
    CYAN   = '\033[0;36m'
    ORANGE = '\033[0;33m'
    RED    = '\033[0;31m'
    GRAY   = '\033[0;90m'

def c(color, text): return f"{color}{text}{C.RESET}"
def ok(msg):  print(c(C.GREEN,  f"âœ“ {msg}"))
def err(msg): print(c(C.RED,    f"âœ— {msg}"), file=sys.stderr)
def info(msg): print(c(C.CYAN,  f"  {msg}"))
def dim(msg): print(c(C.DIM,    f"  {msg}"))

# â”€â”€ API KEY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_key():
    if KEY_FILE.exists():
        return KEY_FILE.read_text().strip()
    # Auto-create key
    print(c(C.ORANGE, "No API key found. Creating one..."))
    try:
        data = json.dumps({'identity': os.environ.get('USER','user'), 'role':'user'}).encode()
        req = urllib.request.Request(f'{AMALLO_URL}/amallo/keys/create', data=data,
                                     headers={'Content-Type':'application/json'})
        with urllib.request.urlopen(req, timeout=10) as r:
            resp = json.loads(r.read())
            key = resp['key']
            KEY_FILE.parent.mkdir(parents=True, exist_ok=True)
            KEY_FILE.write_text(key)
            KEY_FILE.chmod(0o600)
            ok(f"Created key: {key}")
            return key
    except Exception as e:
        err(f"Could not create key: {e}")
        sys.exit(1)

# â”€â”€ MEMORY / SESSION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_session():
    if SESSION_FILE.exists():
        try:
            return json.loads(SESSION_FILE.read_text())
        except:
            pass
    return {'messages': [], 'model': MODEL, 'id': uuid.uuid4().hex[:8]}

def save_session(session):
    SESSION_FILE.parent.mkdir(parents=True, exist_ok=True)
    SESSION_FILE.write_text(json.dumps(session))

def log_history(role, content):
    HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(HISTORY_FILE, 'a') as f:
        f.write(json.dumps({'ts': int(time.time()), 'role': role, 'content': content}) + '\n')

def trim_context(messages):
    # Keep system message + last N messages
    sys_msgs = [m for m in messages if m.get('role') == 'system']
    other    = [m for m in messages if m.get('role') != 'system']
    return sys_msgs + other[-MAX_CONTEXT:]

# â”€â”€ AI CALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def ask_ai(messages, model=None, max_tokens=1024):
    key = get_key()
    mdl = model or MODEL
    mdl = MODEL_ALIASES.get(mdl, mdl)  # resolve alias

    # Route to correct backend based on model
    if mdl in ('brain',):
        endpoint = f'{BRAIN_URL}/v1/chat/completions'
    elif mdl.startswith('GSAI-ML/') or mdl.startswith('inclusionAI/LLaDA'):
        endpoint = f'{DIFFUSION_URL}/v1/chat/completions'
    else:
        endpoint = f'{AMALLO_URL}/v1/chat/completions'

    try:
        data = json.dumps({
            'model': mdl,
            'messages': messages,
            'max_tokens': max_tokens,
            'temperature': 0.7
        }).encode()
        req = urllib.request.Request(
            endpoint, data=data,
            headers={'Authorization': f'Bearer {key}', 'Content-Type': 'application/json'})
        with urllib.request.urlopen(req, timeout=60) as r:
            resp = json.loads(r.read())
            content = resp['choices'][0]['message']['content']
            # Clean artifacts + Amallo-specific noise
            content = re.sub(r'<\|end of response\|>', '', content)
            content = re.sub(r'\[No inference backend available.*?\]', '[Amallo: model not loaded]', content)
            return content.strip()
    except urllib.error.URLError:
        err("Cannot reach Amallo. Check connection or run local server.")
        sys.exit(1)
    except Exception as e:
        err(f"API error: {e}")
        return None

# â”€â”€ SCRAPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def scrape(url, folder=None, session=None):
    print(c(C.CYAN, f"ğŸ•·  Scraping: {url}"))

    # Fetch raw content
    try:
        req = urllib.request.Request(url, headers={
            'User-Agent': 'Mozilla/5.0 (axis/1.0; sovereign-scraper)'
        })
        with urllib.request.urlopen(req, timeout=30) as r:
            raw = r.read()
            content_type = r.headers.get('Content-Type','')
    except Exception as e:
        err(f"Fetch failed: {e}")
        return None

    # Extract text
    try:
        html = raw.decode('utf-8', errors='ignore')
    except:
        html = raw.decode('latin-1', errors='ignore')

    # Strip HTML tags â†’ clean text
    text = re.sub(r'<script[^>]*>.*?</script>', '', html, flags=re.DOTALL|re.IGNORECASE)
    text = re.sub(r'<style[^>]*>.*?</style>',  '', text,  flags=re.DOTALL|re.IGNORECASE)
    text = re.sub(r'<[^>]+>', ' ', text)
    text = re.sub(r'&nbsp;', ' ', text)
    text = re.sub(r'&amp;',  '&', text)
    text = re.sub(r'&lt;',   '<', text)
    text = re.sub(r'&gt;',   '>', text)
    text = re.sub(r'\s+',    ' ', text).strip()

    # Get title
    title_match = re.search(r'<title[^>]*>(.*?)</title>', html, re.IGNORECASE|re.DOTALL)
    title = re.sub(r'\s+', ' ', title_match.group(1)).strip() if title_match else url

    ok(f"Fetched: {title[:60]}")
    info(f"Content: {len(text):,} chars")

    # Save to folder
    saved_path = None
    if folder:
        dest = Path(folder)
        dest.mkdir(parents=True, exist_ok=True)
        # Sanitize filename from URL
        slug = re.sub(r'[^a-zA-Z0-9]+', '-', urllib.parse.urlparse(url).path)
        slug = slug.strip('-') or 'index'
        ts   = int(time.time())
        # Save raw HTML
        html_file = dest / f"{slug}-{ts}.html"
        html_file.write_text(html)
        # Save clean text
        txt_file = dest / f"{slug}-{ts}.txt"
        txt_file.write_text(f"URL: {url}\nTitle: {title}\n\n{text}")
        saved_path = str(txt_file)
        ok(f"Saved: {txt_file}")
        ok(f"HTML:  {html_file}")

    # AI summary
    print(c(C.BLUE, "\nğŸ“‹ Summarizing..."))
    preview = text[:3000]
    msgs = [{
        'role': 'user',
        'content': f'Summarize this webpage content concisely. URL: {url}\nTitle: {title}\n\nContent:\n{preview}'
    }]
    summary = ask_ai(msgs, max_tokens=400)
    if summary:
        print()
        print(c(C.BOLD, "Summary:"))
        for line in summary.split('\n'):
            print(f"  {line}")

    # Add to session context
    if session is not None:
        context_snippet = text[:2000]
        session['messages'].append({
            'role': 'user',
            'content': f'[Scraped {url}]\n{context_snippet}'
        })
        session['messages'].append({
            'role': 'assistant',
            'content': summary or 'Scraped content added to context.'
        })
        session['messages'] = trim_context(session['messages'])
        save_session(session)
        dim("(Content added to chat memory - you can now ask questions about it)")

    return summary

# â”€â”€ SLASH COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS = {}

def command(name, aliases=(), usage='', desc=''):
    def decorator(fn):
        COMMANDS[name] = {'fn': fn, 'usage': usage, 'desc': desc}
        for a in aliases:
            COMMANDS[a] = COMMANDS[name]
        return fn
    return decorator

@command('/scrape', aliases=('/sc',),
         usage='/scrape <url> [folder]',
         desc='Scrape a URL, summarize it, save to folder, add to memory')
def cmd_scrape(args, session):
    parts = args.strip().split()
    if not parts:
        url = input(c(C.ORANGE, "URL to scrape: ")).strip()
        if not url: return "Cancelled."
        parts = [url]
    url = parts[0]
    if not url.startswith('http'):
        url = 'https://' + url
    folder = parts[1] if len(parts) > 1 else None
    scrape(url, folder, session)

@command('/run', aliases=('/!', '/exec'),
         usage='/run <bash command>',
         desc='Run a shell command and add output to context')
def cmd_run(args, session):
    if not args.strip():
        args = input(c(C.ORANGE, "Command to run: ")).strip()
    print(c(C.DIM, f"$ {args}"))
    try:
        result = subprocess.run(args, shell=True, capture_output=True, text=True, timeout=30)
        output = (result.stdout + result.stderr).strip()
        print(output)
        # Add to context
        session['messages'].append({'role':'user',    'content': f'[Command: {args}]\n{output}'})
        session['messages'].append({'role':'assistant','content': 'Command output added to context.'})
        session['messages'] = trim_context(session['messages'])
        save_session(session)
    except Exception as e:
        err(str(e))

@command('/read', aliases=('/r',),
         usage='/read <file>',
         desc='Read a file and add its content to memory')
def cmd_read(args, session):
    path = args.strip()
    if not path:
        path = input(c(C.ORANGE, "File to read: ")).strip()
    try:
        content = Path(path).read_text()
        info(f"Read {len(content):,} chars from {path}")
        session['messages'].append({'role':'user',     'content': f'[File: {path}]\n{content[:4000]}'})
        session['messages'].append({'role':'assistant','content': f'File {path} loaded into context.'})
        session['messages'] = trim_context(session['messages'])
        save_session(session)
        ok("Added to memory")
    except Exception as e:
        err(str(e))

@command('/save', aliases=('/s',),
         usage='/save [filename]',
         desc='Save last AI response to a file')
def cmd_save(args, session):
    msgs = [m for m in session['messages'] if m['role'] == 'assistant']
    if not msgs:
        err("No AI response to save yet.")
        return
    content = msgs[-1]['content']
    path = args.strip() or f"axis-save-{int(time.time())}.txt"
    Path(path).write_text(content)
    ok(f"Saved to {path}")

@command('/model', aliases=('/m',),
         usage='/model <name>',
         desc='Switch AI model (qwen, glm4, dolphin, nano)')
def cmd_model(args, session):
    global MODEL
    name = args.strip()
    if not name:
        print(c(C.BOLD, f"Current model: {session.get('model', MODEL)}"))
        # List available
        key = get_key()
        req = urllib.request.Request(f'{AMALLO_URL}/v1/models',
                                     headers={'Authorization': f'Bearer {key}'})
        with urllib.request.urlopen(req, timeout=10) as r:
            models = json.loads(r.read())
            print(c(C.BOLD, "Available:"))
            for m in models.get('data', []):
                print(f"  â€¢ {m['id']}")
        return
    session['model'] = name
    MODEL = name
    save_session(session)
    ok(f"Switched to: {name}")

@command('/models', aliases=(),
         usage='/models',
         desc='List available models')
def cmd_models(args, session):
    cmd_model('', session)

@command('/chain', aliases=('/c',),
         usage='/chain',
         desc='Toggle chain mode: auto-run code from each AI response')
def cmd_chain(args, session):
    session['chain'] = not session.get('chain', False)
    state = session['chain']
    save_session(session)
    if state:
        print(c(C.PURPLE, "  â›“  CHAIN ON"))
        print(c(C.DIM,    "  On each response:"))
        print(c(C.DIM,    "    1. double Enter (clears any y/n gate)"))
        print(c(C.DIM,    "    2. extract code from response"))
        print(c(C.DIM,    "    3. paste + run it"))
        print(c(C.DIM,    "  /chain again or Ctrl+C to stop"))
    else:
        print(c(C.DIM, "  â›“  CHAIN OFF"))

@command('/clear', aliases=('/reset',),
         usage='/clear',
         desc='Clear conversation memory (start fresh)')
def cmd_clear(args, session):
    session['messages'] = []
    save_session(session)
    ok("Memory cleared")

@command('/history', aliases=('/h',),
         usage='/history [n]',
         desc='Show conversation history')
def cmd_history(args, session):
    n = int(args.strip()) if args.strip().isdigit() else 10
    msgs = session['messages'][-n:]
    if not msgs:
        dim("No history yet.")
        return
    for m in msgs:
        role = m['role']
        content = m['content'][:100] + '...' if len(m['content']) > 100 else m['content']
        color = C.GREEN if role == 'user' else C.BLUE
        print(c(color, f"{role}: ") + content)

@command('/cymatics', aliases=('/cym', '/mandala'),
         usage='/cymatics <text>',
         desc='Visualize AI response as cymatic frequency mandala')
def cmd_cymatics(args, session):
    text = args.strip()
    if not text:
        text = input(c(C.ORANGE, "Text to visualize: ")).strip()
    if not text:
        return
    
    try:
        tools_dir = Path(__file__).parent / 'tools'
        cymatics_script = tools_dir / 'cymatics.py'
        
        if not cymatics_script.exists():
            err(f"Cymatics tool not found at {cymatics_script}")
            return
        
        # Generate cymatics
        result = subprocess.run(['python3', str(cymatics_script), text],
                              capture_output=True, text=True, timeout=30)
        
        if result.returncode != 0:
            err(f"Cymatics generation failed: {result.stderr}")
            return
        
        png_path = result.stdout.strip().split('\n')[-1]
        
        if not png_path or not Path(png_path).exists():
            err("Cymatics image not created")
            return
        
        # Open image (xdg-open, open on macOS, or display on Linux)
        try:
            if subprocess.run(['which', 'xdg-open'], capture_output=True).returncode == 0:
                subprocess.Popen(['xdg-open', png_path])
            elif subprocess.run(['which', 'open'], capture_output=True).returncode == 0:
                subprocess.Popen(['open', png_path])
            elif subprocess.run(['which', 'display'], capture_output=True).returncode == 0:
                subprocess.Popen(['display', png_path])
            else:
                ok(f"Cymatics saved: {png_path}")
                return
        except:
            pass
        
        ok(f"Cymatics mandala opened: {png_path}")
    except Exception as e:
        err(f"Error: {e}")

@command('/help', aliases=('/?', '/commands'),
         usage='/help',
         desc='Show all commands')
def cmd_help(args, session):
    print()
    print(c(C.BOLD + C.PURPLE, "  axis commands"))
    print(c(C.DIM, "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))
    seen = set()
    for name, cmd in COMMANDS.items():
        if cmd['fn'] in seen: continue
        seen.add(cmd['fn'])
        print(f"  {c(C.CYAN, cmd['usage'].ljust(28))} {cmd['desc']}")
    print()
    print(c(C.DIM, "  Or just type anything â€” axis will figure it out."))
    print()

# â”€â”€ FILESYSTEM / PROCESS / CONFIG COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def cmd_ls(args, session):
    """List directory contents. Usage: /ls [path] [--depth N]"""
    parts = args.split() if args else ['.']
    depth = 2
    path = '.'
    i = 0
    while i < len(parts):
        if parts[i] == '--depth' and i+1 < len(parts):
            depth = int(parts[i+1]); i += 2
        else:
            path = parts[i]; i += 1
    path = os.path.expanduser(path)
    lines = []
    def walk(p, d):
        if d < 0: return
        try:
            entries = sorted(os.scandir(p), key=lambda e: (not e.is_dir(), e.name))
        except PermissionError:
            lines.append(f"[DENIED] {p}"); return
        for e in entries:
            prefix = '[DIR] ' if e.is_dir() else '[FILE]'
            lines.append(f"{prefix} {e.path}")
            if e.is_dir() and d > 0:
                walk(e.path, d-1)
    walk(path, depth-1)
    return '\n'.join(lines) or '(empty)'

def cmd_cat(args, session):
    """Read file contents. Usage: /cat <file> [--offset N] [--lines N]"""
    parts = args.split()
    path = offset = length = None
    i = 0
    while i < len(parts):
        if parts[i] == '--offset' and i+1 < len(parts):
            offset = int(parts[i+1]); i += 2
        elif parts[i] == '--lines' and i+1 < len(parts):
            length = int(parts[i+1]); i += 2
        else:
            path = parts[i]; i += 1
    if not path: return 'Usage: /cat <file> [--offset N] [--lines N]'
    path = os.path.expanduser(path)
    try:
        lines = open(path).readlines()
        start = offset or 0
        end = start + length if length else len(lines)
        numbered = [f"{start+i+1:4d} | {l.rstrip()}" for i, l in enumerate(lines[start:end])]
        return '\n'.join(numbered)
    except Exception as e:
        return f'Error: {e}'

def cmd_write(args, session):
    """Write content to file. Usage: /write <file> <content>"""
    parts = args.split(' ', 1)
    if len(parts) < 2: return 'Usage: /write <file> <content>'
    path = os.path.expanduser(parts[0])
    os.makedirs(os.path.dirname(path) or '.', exist_ok=True)
    open(path, 'w').write(parts[1])
    return f'Written: {path} ({len(parts[1])} chars)'

def cmd_mkdir(args, session):
    """Create directory. Usage: /mkdir <path>"""
    path = os.path.expanduser(args.strip())
    os.makedirs(path, exist_ok=True)
    return f'Created: {path}'

def cmd_mv(args, session):
    """Move/rename file. Usage: /mv <src> <dst>"""
    parts = args.split()
    if len(parts) != 2: return 'Usage: /mv <src> <dst>'
    shutil.move(os.path.expanduser(parts[0]), os.path.expanduser(parts[1]))
    return f'Moved: {parts[0]} â†’ {parts[1]}'

def cmd_stat(args, session):
    """Get file metadata. Usage: /stat <path>"""
    path = os.path.expanduser(args.strip())
    try:
        s = os.stat(path)
        is_dir = os.path.isdir(path)
        info_d = {
            'path': path,
            'type': 'directory' if is_dir else 'file',
            'size': s.st_size,
            'created': time.ctime(s.st_ctime),
            'modified': time.ctime(s.st_mtime),
            'permissions': oct(s.st_mode)[-4:],
        }
        if not is_dir:
            try:
                with open(path) as f:
                    lns = f.readlines()
                info_d['lineCount'] = len(lns)
                info_d['lastLine'] = len(lns) - 1
            except: pass
        return '\n'.join(f'{k}: {v}' for k,v in info_d.items())
    except Exception as e:
        return f'Error: {e}'

def cmd_find(args, session):
    """Search for files. Usage: /find <pattern> [path]"""
    parts = args.split()
    if not parts: return 'Usage: /find <pattern> [path]'
    pattern = parts[0]
    path = parts[1] if len(parts) > 1 else '.'
    result = subprocess.run(['find', path, '-name', f'*{pattern}*', '-not', '-path', '*/.*'],
                           capture_output=True, text=True, timeout=10)
    return result.stdout.strip() or 'No results'

def cmd_grep(args, session):
    """Search file contents. Usage: /grep <pattern> [path]"""
    parts = args.split(' ', 1)
    if not parts: return 'Usage: /grep <pattern> [path]'
    pattern = parts[0]
    path = parts[1].strip() if len(parts) > 1 else '.'
    result = subprocess.run(['rg', '--no-heading', '-n', pattern, path],
                           capture_output=True, text=True, timeout=10)
    if result.returncode != 0:
        result = subprocess.run(['grep', '-rn', pattern, path],
                               capture_output=True, text=True, timeout=10)
    out = result.stdout.strip()
    lines = out.split('\n')
    return '\n'.join(lines[:50]) + (f'\n... ({len(lines)-50} more)' if len(lines) > 50 else '') if out else 'No matches'

def cmd_ps(args, session):
    """List running processes. Usage: /ps [filter]"""
    result = subprocess.run(['ps', 'aux', '--sort=-%cpu'],
                           capture_output=True, text=True)
    lines = result.stdout.strip().split('\n')
    header = lines[0]
    procs = lines[1:]
    if args.strip():
        procs = [p for p in procs if args.strip().lower() in p.lower()]
    out = [header] + procs[:30]
    return '\n'.join(out)

def cmd_kill(args, session):
    """Kill process by PID. Usage: /kill <pid>"""
    import signal
    try:
        pid = int(args.strip())
        os.kill(pid, signal.SIGTERM)
        return f'Sent SIGTERM to PID {pid}'
    except Exception as e:
        return f'Error: {e}'

# Persistent process sessions
_PROCS = {}

def cmd_proc(args, session):
    """Start a persistent process session. Usage: /proc <command>"""
    if not args.strip(): return 'Usage: /proc <command>'
    pid_key = uuid.uuid4().hex[:8]
    proc = subprocess.Popen(
        args.strip(), shell=True, stdin=subprocess.PIPE,
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1
    )
    _PROCS[pid_key] = proc
    return f'Started session [{pid_key}] PID={proc.pid}\nUse: /send {pid_key} <input>\n     /output {pid_key}\n     /kill-session {pid_key}'

def cmd_send(args, session):
    """Send input to a process session. Usage: /send <session_id> <input>"""
    import fcntl, select
    parts = args.split(' ', 1)
    if len(parts) < 2: return 'Usage: /send <session_id> <input>'
    sid, inp = parts
    proc = _PROCS.get(sid)
    if not proc: return f'No session: {sid}'
    try:
        proc.stdin.write(inp + '\n'); proc.stdin.flush()
        time.sleep(0.3)
        output = []
        flags = fcntl.fcntl(proc.stdout, fcntl.F_GETFL)
        fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)
        try:
            while True:
                line = proc.stdout.readline()
                if not line: break
                output.append(line.rstrip())
        except: pass
        fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags)
        return '\n'.join(output) if output else '(no output yet â€” use /output <sid>)'
    except Exception as e:
        return f'Error: {e}'

def cmd_output(args, session):
    """Read output from process session. Usage: /output <session_id>"""
    import fcntl
    sid = args.strip()
    proc = _PROCS.get(sid)
    if not proc: return f'No session: {sid}'
    output = []
    flags = fcntl.fcntl(proc.stdout, fcntl.F_GETFL)
    fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    try:
        while True:
            line = proc.stdout.readline()
            if not line: break
            output.append(line.rstrip())
    except: pass
    fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags)
    return '\n'.join(output) if output else '(no new output)'

def cmd_sessions(args, session):
    """List active process sessions. Usage: /sessions"""
    if not _PROCS: return 'No active sessions'
    lines = []
    for sid, proc in list(_PROCS.items()):
        alive = proc.poll() is None
        status = 'running' if alive else f'exited({proc.returncode})'
        lines.append(f'[{sid}] PID={proc.pid} {status}')
        if not alive: del _PROCS[sid]
    return '\n'.join(lines)

def cmd_config(args, session):
    """Get/set axis config. Usage: /config [key] [value]"""
    config_path = Path.home() / '.config/amallo/axis-config.json'
    config_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        cfg = json.loads(config_path.read_text())
    except:
        cfg = {'amallo_url': AMALLO_URL, 'model': MODEL, 'allowed_dirs': [str(Path.home())]}

    parts = args.strip().split(' ', 1) if args.strip() else []
    if not parts:
        return json.dumps(cfg, indent=2)
    elif len(parts) == 1:
        return str(cfg.get(parts[0], f'Key not found: {parts[0]}'))
    else:
        key, val = parts
        try: val = json.loads(val)
        except: pass
        cfg[key] = val
        config_path.write_text(json.dumps(cfg, indent=2))
        return f'Set {key} = {val}'

VCHAT_LOG = Path.home() / '.vchat-log.txt'
_VCHAT_ACTIVE = {'on': False}

def cmd_vchat(args, session):
    """
    /vchat â€” invisible voice chat. Speak â†’ transcribe â†’ send to amallo â†’ response spoken aloud.
    /vchat start        : begin listening loop (classic beep-pause-transcribe 5s windows)
    /vchat stream       : streaming mode with overlapping 3s windows & real-time responses
    /vchat stop         : stop voice chat
    /vchat log          : show session transcript
    /vchat clear        : clear log
    """
    import threading, datetime
    sub = args.strip().lower() if args.strip() else 'start'

    if sub == 'log':
        if VCHAT_LOG.exists():
            return VCHAT_LOG.read_text()
        return '(no vchat log yet)'

    if sub == 'clear':
        VCHAT_LOG.write_text('')
        return 'vchat log cleared'

    if sub == 'stop':
        _VCHAT_ACTIVE['on'] = False
        return '[vchat] stopped'

    # Load token & config (shared by both start and stream)
    token = session.get('token','')
    model = session.get('model', MODEL)
    url   = session.get('amallo_url', AMALLO_URL)
    
    # Try loading from axis-mundi config if not in session
    if not token:
        try:
            axis_cfg = Path.home() / '.config/axis-mundi/config.json'
            if axis_cfg.exists():
                cfg = json.loads(axis_cfg.read_text())
                token = cfg.get('token', '')
                url = cfg.get('server', url)
        except: pass

    if sub == 'start':
        if _VCHAT_ACTIVE['on']:
            return '[vchat] already running â€” speak now'
        _VCHAT_ACTIVE['on'] = True

        def vchat_loop():
            nd = str(Path.home() / 'nerd-dictation/nerd-dictation')
            spd = 'spd-say'

            def log(role, text):
                ts = datetime.datetime.now().strftime('%H:%M:%S')
                with open(VCHAT_LOG, 'a') as f:
                    f.write(f'[{ts}] {role}: {text}\n')

            def say(text):
                # strip code-like lines
                clean = ' '.join(
                    l.strip() for l in text.splitlines()
                    if l.strip() and not l.strip().startswith(('$','#','```','>>>','|','{'))
                    and not l.startswith('    ')
                )
                if clean:
                    subprocess.Popen([spd, '-r', '20', clean])

            def transcribe():
                """One-shot nerd-dictation capture (~5 seconds)"""
                try:
                    env = os.environ.copy()
                    env['DISPLAY'] = ':0'
                    r = subprocess.run(
                        [nd, 'begin', '--timeout=5', '--output=STDOUT'],
                        capture_output=True, text=True, timeout=10, env=env
                    )
                    return r.stdout.strip()
                except Exception as e:
                    return ''

            say('Voice chat active. Speak after the beep.')
            log('SYSTEM', 'vchat session started')

            while _VCHAT_ACTIVE['on']:
                try:
                    # signal ready
                    subprocess.run(['spd-say', '-r', '50', 'go'], capture_output=True)
                    spoken = transcribe()
                    if not spoken or len(spoken) < 2:
                        continue
                    log('MARCUS', spoken)
                    # send to amallo
                    msgs = [{'role':'user','content': spoken}]
                    payload = json.dumps({'model': model, 'messages': msgs, 'stream': False})
                    req = urllib.request.Request(
                        url.rstrip('/') + '/v1/chat/completions',
                        data=payload.encode(),
                        headers={'Content-Type':'application/json','Authorization':f'Bearer {token}'},
                        method='POST'
                    )
                    with urllib.request.urlopen(req, timeout=30) as resp:
                        data = json.loads(resp.read())
                    reply = data['choices'][0]['message']['content']
                    log('AMALLO', reply)
                    say(reply)
                except Exception as e:
                    log('ERROR', str(e))
                    time.sleep(1)

        t = threading.Thread(target=vchat_loop, daemon=True)
        t.start()
        return '[vchat] started â€” speak after each "go" beep. /vchat stop to end. /vchat log to review.'

    if sub == 'stream':
        # Streaming mode with overlapping windows & real-time responses
        if _VCHAT_ACTIVE['on']:
            return '[vchat stream] already running'
        _VCHAT_ACTIVE['on'] = True
        
        # Check/install pyaudio
        try:
            import pyaudio
        except ImportError:
            try:
                subprocess.run(['pip', 'install', 'pyaudio'], capture_output=True, timeout=60)
            except Exception as e:
                _VCHAT_ACTIVE['on'] = False
                return f'[vchat stream] Failed to install pyaudio: {e}'

        def vchat_stream_loop():
            import pyaudio
            import wave
            import threading as thr
            
            spd = 'spd-say'

            def log(role, text):
                ts = datetime.datetime.now().strftime('%H:%M:%S')
                with open(VCHAT_LOG, 'a') as f:
                    f.write(f'[{ts}] {role}: {text}\n')

            def say(text):
                """Speak text, stripping code-like lines."""
                clean = ' '.join(
                    l.strip() for l in text.splitlines()
                    if l.strip() and not l.strip().startswith(('$','#','```','>>>','|','{'))
                    and not l.startswith('    ')
                )
                if clean:
                    subprocess.Popen([spd, '-r', '20', clean])

            def say_sentence(text):
                """Speak a sentence (ends with . ! ?)"""
                text = text.strip()
                if text and any(text.endswith(p) for p in '.!?'):
                    say(text)

            def capture_audio_chunk(duration=3.0):
                """Capture audio for ~duration seconds and transcribe."""
                try:
                    nd = str(Path.home() / 'nerd-dictation/nerd-dictation')
                    env = os.environ.copy()
                    env['DISPLAY'] = ':0'
                    # Use shorter timeout for streaming feel
                    r = subprocess.run(
                        [nd, 'begin', f'--timeout={int(duration)}', '--output=STDOUT'],
                        capture_output=True, text=True, timeout=int(duration)+5, env=env
                    )
                    return r.stdout.strip()
                except Exception as e:
                    return ''

            def stream_response(spoken_text):
                """Send to API with stream=true, parse tokens, speak sentences."""
                try:
                    msgs = [{'role':'user','content': spoken_text}]
                    payload = json.dumps({'model': model, 'messages': msgs, 'stream': True})
                    req = urllib.request.Request(
                        url.rstrip('/') + '/v1/chat/completions',
                        data=payload.encode(),
                        headers={'Content-Type':'application/json','Authorization':f'Bearer {token}'},
                        method='POST'
                    )
                    full_response = ''
                    sentence_buffer = ''
                    
                    with urllib.request.urlopen(req, timeout=60) as resp:
                        for line in resp:
                            line_str = line.decode('utf-8').strip()
                            if not line_str or line_str.startswith(':'):
                                continue
                            if line_str.startswith('data: '):
                                line_str = line_str[6:]
                            if line_str == '[DONE]':
                                break
                            try:
                                data = json.loads(line_str)
                                token_content = data.get('choices', [{}])[0].get('delta', {}).get('content', '')
                                if token_content:
                                    full_response += token_content
                                    sentence_buffer += token_content
                                    # Check if sentence is complete
                                    if any(sentence_buffer.endswith(p) for p in '.!?'):
                                        say_sentence(sentence_buffer)
                                        sentence_buffer = ''
                            except: pass
                    
                    # Speak any remaining sentence
                    if sentence_buffer.strip():
                        say_sentence(sentence_buffer + '.')
                    
                    return full_response
                except Exception as e:
                    log('ERROR', f'stream_response: {str(e)}')
                    return ''

            log('SYSTEM', 'vchat stream session started')
            say('Streaming voice chat active. Listening continuously.')

            while _VCHAT_ACTIVE['on']:
                try:
                    spoken = capture_audio_chunk(duration=3.0)
                    if spoken and len(spoken) > 2:
                        log('MARCUS', spoken)
                        reply = stream_response(spoken)
                        if reply:
                            log('AMALLO', reply)
                except Exception as e:
                    log('ERROR', str(e))
                    time.sleep(1)

        t = threading.Thread(target=vchat_stream_loop, daemon=True)
        t.start()
        return '[vchat stream] started â€” continuous 3s listening with real-time responses. /vchat stop to end.'

    return 'Usage: /vchat [start|stream|stop|log|clear]'


# â”€â”€ /browse â€” AXISCHROME sovereign AI browser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def cmd_browse(args, session):
    """
    /browse <url or search query>
    AI sees the page, answers your task. No Google. No tracking.

    Examples:
      /browse what is the current price of bitcoin
      /browse https://huggingface.co find the top GGUF models
      /browse site:github.com sovereign GGUF inference server
    """
    import subprocess, sys
    if not args:
        return 'Usage: /browse <url_or_search_query> [optional task description]'

    axischrome = Path(__file__).parent / 'tools' / 'axischrome.py'
    if not axischrome.exists():
        # try relative to sovereign-stack
        axischrome = Path.home() / 'sovereign-stack' / 'tools' / 'axischrome.py'
    if not axischrome.exists():
        return '[browse] axischrome.py not found â€” expected at tools/axischrome.py'

    query = ' '.join(args)
    print(f'\n[axischrome] launching...\n')
    try:
        subprocess.run([sys.executable, str(axischrome)] + args, check=False)
    except Exception as e:
        return f'[browse] error: {e}'
    return ''


# â”€â”€ /addnode â€” SSH into a node and add it to the sovereign mesh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def cmd_addnode(args, session):
    """
    /addnode <ip> [user]
    SSH into a node, detect what's running, add to config.

    Example:
      /addnode 72.61.78.161
      /addnode 72.61.78.161 root
    """
    import getpass, subprocess, json, urllib.request

    if not args:
        return 'Usage: /addnode <ip> [user]'

    ip   = args[0]
    user = args[1] if len(args) > 1 else 'root'

    # Prompt for password exactly like SSH
    try:
        password = getpass.getpass(f'{user}@{ip}\'s password: ')
    except (KeyboardInterrupt, EOFError):
        return '\n[addnode] cancelled'

    print(f'[addnode] connecting to {user}@{ip}...')

    # probe via SSH: check amallo status + running models
    probe = (
        "curl -s --max-time 5 http://localhost:8200/amallo/status 2>/dev/null || "
        "curl -s --max-time 5 http://localhost:11434/api/tags 2>/dev/null || "
        "echo '{\"probe\":\"none\"}'"
    )

    try:
        result = subprocess.run(
            ['sshpass', '-p', password, 'ssh',
             '-o', 'StrictHostKeyChecking=no',
             '-o', 'ConnectTimeout=8',
             f'{user}@{ip}', probe],
            capture_output=True, text=True, timeout=15
        )
        raw = result.stdout.strip()
    except FileNotFoundError:
        # sshpass not installed â€” try paramiko
        try:
            import paramiko
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(ip, username=user, password=password, timeout=8)
            _, stdout, _ = client.exec_command(probe)
            raw = stdout.read().decode().strip()
            client.close()
        except ImportError:
            return '[addnode] install sshpass or paramiko: pip install paramiko'
        except Exception as e:
            return f'[addnode] SSH failed: {e}'
    except Exception as e:
        return f'[addnode] connection error: {e}'

    # parse probe response
    models = []
    node_type = 'unknown'
    try:
        data = json.loads(raw)
        if 'models' in data:          # amallo status
            models = [m if isinstance(m, str) else m.get('name','?') for m in data.get('models', [])]
            node_type = 'amallo'
        elif 'models' in data:         # ollama tags
            models = [m.get('name','?') for m in data.get('models', [])]
            node_type = 'ollama'
    except Exception:
        node_type = 'raw'

    # create a SOV key on the remote node if amallo
    new_key = None
    if node_type == 'amallo':
        try:
            req = urllib.request.Request(
                f'http://{ip}:8200/amallo/keys/create',
                data=json.dumps({'identity': 'kelushael', 'role': 'admin'}).encode(),
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            resp = json.loads(urllib.request.urlopen(req, timeout=8).read())
            new_key = resp.get('key')
        except Exception:
            pass  # node may be behind nginx on 443

    # add to config
    cfg_path = Path.home() / '.config' / 'axis-mundi' / 'config.json'
    cfg = json.loads(cfg_path.read_text()) if cfg_path.exists() else {}
    nodes = cfg.get('nodes', {})

    node_id = f'node-{ip.replace(".", "-")}'
    nodes[node_id] = {
        'ip': ip,
        'user': user,
        'type': node_type,
        'models': models,
        'key': new_key or '',
        'added': __import__('time').strftime('%Y-%m-%dT%H:%M:%SZ')
    }
    cfg['nodes'] = nodes
    cfg_path.write_text(json.dumps(cfg, indent=2))

    lines = [f'[addnode] âœ“ connected to {user}@{ip}']
    lines.append(f'[addnode] type: {node_type}')
    if models:
        lines.append(f'[addnode] models: {", ".join(models)}')
    if new_key:
        lines.append(f'[addnode] key: {new_key}')
    lines.append(f'[addnode] saved as "{node_id}" in config')
    return '\n'.join(lines)


def cmd_mesh(args, session):
    """
    /mesh [deploy <role> <ip>|status|nodes]
    View and manage the sovereign mesh nodes.

    Examples:
      /mesh              â€” show all mesh nodes + live ping
      /mesh status       â€” same
      /mesh nodes        â€” raw node list
    """
    import urllib.request, json, os, concurrent.futures

    MESH_NODES = {
        'gateway':  {'ip': '76.13.24.113',  'role': 'GATEWAY',  'host': 'axismundi.fun',        'check': 'https://axismundi.fun/amallo/status'},
        'model':    {'ip': '187.77.208.28', 'role': 'MODEL',    'host': 'srv1399361',            'check': 'https://axismundi.fun/v1/models'},
        'web':      {'ip': '185.28.23.43',  'role': 'WEB',      'host': 'srv1397652',            'check': 'http://185.28.23.43/health'},
        'operator': {'ip': '72.61.78.161',  'role': 'OPERATOR', 'host': 'srv1339155',            'check': 'http://72.61.78.161:8300/health'},
    }
    DEPLOY_CMDS = {
        'gateway':  'bash ~/sovereign-stack/tools/mesh-deploy.sh --role gateway',
        'model':    'bash ~/sovereign-stack/tools/mesh-deploy.sh --role model',
        'web':      'bash ~/sovereign-stack/tools/mesh-deploy.sh --role web',
        'operator': 'bash ~/sovereign-stack/tools/mesh-deploy.sh --role operator',
    }
    SOV_KEY = 'SOV-A8FB-3C9A-570C-656B'

    def ping(node_id, info):
        try:
            req = urllib.request.Request(info['check'], headers={'Authorization': f'Bearer {SOV_KEY}'})
            with urllib.request.urlopen(req, timeout=4) as r:
                return node_id, r.status, r.read(200).decode('utf-8','replace').strip()
        except Exception as e:
            return node_id, 0, str(e)[:60]

    lines = []
    lines.append('')
    lines.append('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')
    lines.append('â•‘          SOVEREIGN MESH â€” axismundi.fun                  â•‘')
    lines.append('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    lines.append('')

    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as ex:
        futures = {ex.submit(ping, nid, info): nid for nid, info in MESH_NODES.items()}
        results = {}
        for f in concurrent.futures.as_completed(futures):
            nid, code, body = f.result()
            results[nid] = (code, body)

    ROLE_PURPOSE = {
        'gateway':  'nginx mesh router / SSL / domain',
        'model':    'pure AI inference â€” dolphin-mistral + glm4',
        'web':      'CLANK UI / dashboard / static assets',
        'operator': 'axis relay / AXISCHROME / green-team',
    }

    for nid, info in MESH_NODES.items():
        code, body = results.get(nid, (0, 'timeout'))
        status_icon = 'ğŸŸ¢' if code in (200, 401) else 'ğŸ”´'
        status_text = 'ONLINE' if code in (200, 401) else f'OFFLINE ({code})'
        lines.append(f'  {status_icon}  {info["role"]:<10} {info["ip"]:<17} {status_text}')
        lines.append(f'      Host:    {info["host"]}')
        lines.append(f'      Purpose: {ROLE_PURPOSE[nid]}')
        if code == 0:
            lines.append(f'      Deploy:  ssh root@{info["ip"]}')
            lines.append(f'               {DEPLOY_CMDS[nid]}')
        lines.append('')

    lines.append(f'  Mesh key: {SOV_KEY}')
    lines.append(f'  Inference â†’ https://axismundi.fun/v1/chat/completions')
    lines.append(f'  CLANK UI  â†’ http://185.28.23.43/clank')
    lines.append(f'  Deploy    â†’ curl https://axismundi.fun/mesh-deploy.sh | bash -s -- --role <role>')
    lines.append('')
    return '\n'.join(lines)


_new_cmds = [
    ('/ls',       'List directory contents',       '/ls [path] [--depth N]',         cmd_ls),
    ('/cat',      'Read file contents',             '/cat <file> [--offset N] [--lines N]', cmd_cat),
    ('/write',    'Write file',                     '/write <file> <content>',        cmd_write),
    ('/mkdir',    'Create directory',               '/mkdir <path>',                  cmd_mkdir),
    ('/mv',       'Move/rename file',               '/mv <src> <dst>',                cmd_mv),
    ('/stat',     'File metadata',                  '/stat <path>',                   cmd_stat),
    ('/find',     'Find files by name',             '/find <pattern> [path]',         cmd_find),
    ('/grep',     'Search file contents',           '/grep <pattern> [path]',         cmd_grep),
    ('/ps',       'List processes',                 '/ps [filter]',                   cmd_ps),
    ('/kill',     'Kill process by PID',            '/kill <pid>',                    cmd_kill),
    ('/proc',     'Start process session',          '/proc <command>',                cmd_proc),
    ('/send',     'Send input to process session',  '/send <session_id> <input>',     cmd_send),
    ('/output',   'Read process session output',    '/output <session_id>',           cmd_output),
    ('/sessions', 'List active process sessions',   '/sessions',                      cmd_sessions),
    ('/config',   'Get/set axis config',            '/config [key] [value]',          cmd_config),
    ('/vchat',    'Invisible voice chat w/ log',   '/vchat [start|stream|stop|log|clear]',  cmd_vchat),
    ('/browse',   'AI sovereign browser',           '/browse <url or search query>',          cmd_browse),
    ('/addnode',  'Add sovereign node to mesh',      '/addnode <ip> [user]',                   cmd_addnode),
    ('/mesh',     'Sovereign mesh status + deploy',  '/mesh [status|nodes]',                   cmd_mesh),
]
for _name, _desc, _usage, _fn in _new_cmds:
    COMMANDS[_name] = {'fn': _fn, 'usage': _usage, 'desc': _desc}

# â”€â”€ DISPATCH SLASH COMMAND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def dispatch(text, session):
    """Handle slash command or pass to AI."""
    text = text.strip()
    if not text: return

    # Parse slash command
    if text.startswith('/'):
        parts = text.split(None, 1)
        name  = parts[0].lower()
        args  = parts[1] if len(parts) > 1 else ''

        if name in COMMANDS:
            try:
                return COMMANDS[name]['fn'](args, session)
            except Exception as e:
                import traceback
                tb = traceback.format_exc()
                # Never leave user stuck â€” buddy diagnoses immediately
                print(c(C.YELLOW, f"\n[axis] command failed: {e}"))
                buddy_msg = [{
                    'role': 'system',
                    'content': (
                        'You are a sovereign AI buddy running in axis CLI. '
                        'A command just crashed. Diagnose the error, explain what went wrong in one sentence, '
                        'then give the exact fix or next step. Be direct. Never leave the user stuck. '
                        'If you can auto-fix it, say exactly what command to run next.'
                    )
                }, {
                    'role': 'user',
                    'content': (
                        f'Command: {text}\n'
                        f'Error: {e}\n'
                        f'Traceback:\n{tb}\n\n'
                        'What went wrong and how do I fix it?'
                    )
                }]
                reply = ask_ai(buddy_msg, max_tokens=300)
                if reply:
                    print()
                    print_response(reply)
                return
        else:
            # Unknown command - let AI figure it out
            print(c(C.DIM, f"Unknown command '{name}'. Asking AI..."))
            intent_msg = [{
                'role': 'system',
                'content': (
                    'You are axis, a sovereign AI CLI. The user typed an unknown slash command. '
                    'Try to understand what they want and do it, or ask them one clarifying question.'
                )
            }, {'role': 'user', 'content': text}]
            reply = ask_ai(intent_msg, max_tokens=300)
            if reply:
                print()
                print_response(reply)
                session['messages'].append({'role':'user',      'content': text})
                session['messages'].append({'role':'assistant', 'content': reply})
                save_session(session)
            return

    # Regular message - send to AI
    session['messages'].append({'role': 'user', 'content': text})
    session['messages'] = trim_context(session['messages'])
    log_history('user', text)

    print(c(C.DIM, "..."), end='\r')
    reply = ask_ai(session['messages'], model=session.get('model', MODEL))

    if not reply:
        # Node down or no response â€” buddy explains and suggests
        print(c(C.YELLOW, '\n[axis] no response from node'))
        print(c(C.DIM,    '  check: is axismundi.fun reachable?'))
        print(c(C.DIM,    '  try:   /config server <url>  or  /addnode <ip>'))
        return
        print(' ' * 10, end='\r')
        print()
        print_response(reply)
        print()
        session['messages'].append({'role': 'assistant', 'content': reply})
        session['messages'] = trim_context(session['messages'])
        log_history('assistant', reply)
        save_session(session)
        return reply   # caller (repl) uses this for chain mode

def print_response(text):
    """Pretty-print AI response."""
    width = min(shutil.get_terminal_size().columns - 4, 80)
    for line in text.split('\n'):
        if line.startswith('```'):
            print(c(C.DIM, '  ' + line))
        elif line.startswith('#'):
            print(c(C.BOLD, '  ' + line))
        elif line.startswith('- ') or line.startswith('* '):
            print(c(C.CYAN, '  â€¢') + ' ' + line[2:])
        else:
            if len(line) > width:
                wrapped = fill(line, width=width)
                for wl in wrapped.split('\n'):
                    print('  ' + wl)
            else:
                print('  ' + line)

def extract_code(text):
    """Pull the first code block out of a response, or return full text."""
    # fenced code block: ```lang\n...code...\n```
    m = re.search(r'```(?:\w+)?\n?([\s\S]*?)```', text)
    if m:
        return m.group(1).strip()
    # single backtick inline and barely any other text
    m = re.search(r'`([^`]+)`', text)
    if m and len(re.sub(r'`[^`]+`', '', text).strip()) < 20:
        return m.group(1).strip()
    return text.strip()

# â”€â”€ MCP SERVER MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MCP_TOOLS = [
    {"name": "read_file", "description": "Read file contents", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}, "offset": {"type": "number"}, "length": {"type": "number"}}, "required": ["path"]}},
    {"name": "write_file", "description": "Write file contents", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}, "content": {"type": "string"}}, "required": ["path", "content"]}},
    {"name": "list_directory", "description": "List directory", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}, "depth": {"type": "number"}}, "required": ["path"]}},
    {"name": "create_directory", "description": "Create directory", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}}, "required": ["path"]}},
    {"name": "move_file", "description": "Move/rename file", "inputSchema": {"type": "object", "properties": {"source": {"type": "string"}, "destination": {"type": "string"}}, "required": ["source", "destination"]}},
    {"name": "get_file_info", "description": "File metadata", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}}, "required": ["path"]}},
    {"name": "start_search", "description": "Search for files or content", "inputSchema": {"type": "object", "properties": {"pattern": {"type": "string"}, "path": {"type": "string"}, "type": {"type": "string", "enum": ["file", "content"]}}, "required": ["pattern"]}},
    {"name": "list_processes", "description": "List running processes", "inputSchema": {"type": "object", "properties": {"filter": {"type": "string"}}}},
    {"name": "kill_process", "description": "Kill process by PID", "inputSchema": {"type": "object", "properties": {"pid": {"type": "number"}}, "required": ["pid"]}},
    {"name": "start_process", "description": "Start a terminal process", "inputSchema": {"type": "object", "properties": {"command": {"type": "string"}}, "required": ["command"]}},
    {"name": "interact_with_process", "description": "Send input to process", "inputSchema": {"type": "object", "properties": {"pid": {"type": "string"}, "input": {"type": "string"}}, "required": ["pid", "input"]}},
    {"name": "read_process_output", "description": "Read process output", "inputSchema": {"type": "object", "properties": {"pid": {"type": "string"}}, "required": ["pid"]}},
    {"name": "list_sessions", "description": "List terminal sessions", "inputSchema": {"type": "object", "properties": {}}},
    {"name": "execute_command", "description": "Execute shell command", "inputSchema": {"type": "object", "properties": {"command": {"type": "string"}}, "required": ["command"]}},
    {"name": "get_config", "description": "Get axis configuration", "inputSchema": {"type": "object", "properties": {}}},
    {"name": "set_config_value", "description": "Set config value", "inputSchema": {"type": "object", "properties": {"key": {"type": "string"}, "value": {}}, "required": ["key", "value"]}},
    {"name": "chat", "description": "Chat with AI via amallo-brain", "inputSchema": {"type": "object", "properties": {"message": {"type": "string"}, "model": {"type": "string"}}, "required": ["message"]}},
    {"name": "operate", "description": "Operate the browser (Kernel Mustard)", "inputSchema": {"type": "object", "properties": {"command": {"type": "string"}}, "required": ["command"]}},
]

def mcp_tool_call(name, args):
    """Dispatch an MCP tool call to the appropriate axis function."""
    dummy_session = {}
    tool_map = {
        'read_file':           lambda a: cmd_cat(f"{a['path']}" + (f" --offset {a['offset']}" if 'offset' in a else '') + (f" --lines {a['length']}" if 'length' in a else ''), dummy_session),
        'write_file':          lambda a: cmd_write(f"{a['path']} {a['content']}", dummy_session),
        'list_directory':      lambda a: cmd_ls(f"{a['path']}" + (f" --depth {a['depth']}" if 'depth' in a else ''), dummy_session),
        'create_directory':    lambda a: cmd_mkdir(a['path'], dummy_session),
        'move_file':           lambda a: cmd_mv(f"{a['source']} {a['destination']}", dummy_session),
        'get_file_info':       lambda a: cmd_stat(a['path'], dummy_session),
        'start_search':        lambda a: cmd_find(f"{a['pattern']} {a.get('path','.')}", dummy_session) if a.get('type') != 'content' else cmd_grep(f"{a['pattern']} {a.get('path','.')}", dummy_session),
        'list_processes':      lambda a: cmd_ps(a.get('filter',''), dummy_session),
        'kill_process':        lambda a: cmd_kill(str(a['pid']), dummy_session),
        'start_process':       lambda a: cmd_proc(a['command'], dummy_session),
        'interact_with_process': lambda a: cmd_send(f"{a['pid']} {a['input']}", dummy_session),
        'read_process_output': lambda a: cmd_output(a['pid'], dummy_session),
        'list_sessions':       lambda a: cmd_sessions('', dummy_session),
        'execute_command':     lambda a: cmd_run(a['command'], dummy_session),
        'get_config':          lambda a: cmd_config('', dummy_session),
        'set_config_value':    lambda a: cmd_config(f"{a['key']} {json.dumps(a['value'])}", dummy_session),
        'chat':                lambda a: ask_ai([{'role': 'user', 'content': a['message']}], model=a.get('model', MODEL)),
        'operate':             lambda a: urllib.request.urlopen(
            urllib.request.Request(
                'http://localhost:8600/api/command',
                data=json.dumps({'cmd': a['command']}).encode(),
                headers={'Content-Type': 'application/json'}
            )
        ).read().decode(),
    }
    fn = tool_map.get(name)
    if not fn: return f'Unknown tool: {name}'
    try:
        return fn(args)
    except Exception as e:
        return f'Error: {e}'

def mcp_server():
    """
    Run axis as an MCP (Model Context Protocol) JSON-RPC 2.0 server over stdio.
    Compatible with Claude Desktop, Cursor, Zed, and any MCP client.

    Add to Claude Desktop config (~/.config/claude/claude_desktop_config.json):
    {
      "mcpServers": {
        "axis": {
          "command": "axis",
          "args": ["--mcp"]
        }
      }
    }
    """
    def send(obj):
        sys.stdout.write(json.dumps(obj) + '\n')
        sys.stdout.flush()

    while True:
        try:
            line = sys.stdin.readline()
            if not line: break
            req = json.loads(line.strip())
        except (json.JSONDecodeError, EOFError):
            continue

        method  = req.get('method', '')
        req_id  = req.get('id')
        params  = req.get('params', {})

        if method == 'initialize':
            send({"jsonrpc": "2.0", "id": req_id, "result": {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}},
                "serverInfo": {
                    "name": "axis",
                    "version": "2.0",
                    "description": "Sovereign AI CLI â€” un-ownable, self-hosted, zero cloud"
                }
            }})

        elif method == 'tools/list':
            send({"jsonrpc": "2.0", "id": req_id, "result": {"tools": MCP_TOOLS}})

        elif method == 'tools/call':
            tool_name = params.get('name', '')
            tool_args = params.get('arguments', {})
            result    = mcp_tool_call(tool_name, tool_args)
            send({"jsonrpc": "2.0", "id": req_id, "result": {
                "content": [{"type": "text", "text": str(result)}],
                "isError": False
            }})

        elif method == 'notifications/initialized':
            pass  # no response needed

        else:
            if req_id is not None:
                send({"jsonrpc": "2.0", "id": req_id, "error": {
                    "code": -32601, "message": f"Method not found: {method}"
                }})

# â”€â”€ INTERACTIVE CHAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def repl(session):
    """Interactive chat mode."""
    model = session.get('model', MODEL)
    print(c(C.PURPLE, f"\n  axis {VERSION}  ") + c(C.DIM, f"model:{model}  /help for commands"))
    print(c(C.DIM, "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))
    print()

    while True:
        try:
            text = input(c(C.GREEN, 'you > ')).strip()
            if not text: continue
            if text.lower() in ('exit', 'quit', 'bye', '/exit', '/quit'):
                print(c(C.DIM, "  bye"))
                break

            reply = dispatch(text, session)

            # â”€â”€ CHAIN MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # After every AI response, if chain is ON:
            #   step 1: double Enter (y) â€” clears any y/n gate silently
            #   step 2: extract code from response
            #   step 3: paste it back as next input and run it
            while reply and session.get('chain'):
                code = extract_code(reply)
                # step 1: two silent 'y' dispatches for confirmation gates
                dispatch('y', session)
                dispatch('y', session)
                # step 2+3: run the extracted code as next prompt
                print(c(C.PURPLE, f"  â›“  chaining: ") + c(C.DIM, code[:80]))
                reply = dispatch(code, session)

        except KeyboardInterrupt:
            print()
            if session.get('chain'):
                session['chain'] = False
                save_session(session)
                print(c(C.DIM, "  â›“  chain stopped"))
            else:
                print(c(C.DIM, "  (Ctrl+C â€” type 'exit' to quit)"))
        except EOFError:
            print()
            break

# â”€â”€ ENTRY POINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    args = sys.argv[1:]
    session = load_session()

    # No args â†’ interactive
    if not args:
        repl(session)
        return

    # Parse --flags
    if args[0] in ('--help', '-h'):
        print(__doc__)
        return

    if args[0] == '--mcp':
        mcp_server()
        return

    if args[0] in ('--version', '-v'):
        print(f"axis {VERSION}")
        return

    if args[0] in ('--scrape', '--amalloscrape'):
        url    = args[1] if len(args) > 1 else input("URL: ").strip()
        folder = args[2] if len(args) > 2 else None
        if not url.startswith('http'): url = 'https://' + url
        scrape(url, folder, session)
        return

    if args[0] == '--clear':
        session['messages'] = []
        save_session(session)
        ok("Memory cleared")
        return

    if args[0] == '--history':
        n = int(args[1]) if len(args) > 1 else 10
        cmd_history(str(n), session)
        return

    if args[0] == '--model':
        if len(args) > 1:
            cmd_model(args[1], session)
        else:
            cmd_model('', session)
        return

    # Everything else: one-shot query or slash command
    text = ' '.join(args)

    # Check if it looks like a question/task
    if not text.startswith('/') and not text.startswith('--'):
        # One-shot query
        session['messages'].append({'role': 'user', 'content': text})
        session['messages'] = trim_context(session['messages'])
        log_history('user', text)

        reply = ask_ai(session['messages'], model=session.get('model', MODEL))
        if reply:
            print_response(reply)
            print()
            session['messages'].append({'role': 'assistant', 'content': reply})
            save_session(session)
    else:
        dispatch(text, session)

if __name__ == '__main__':
    main()
