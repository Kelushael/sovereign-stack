#!/usr/bin/env python3
"""
axis - Sovereign AI CLI
One shot terminal. Same memory. Slash commands everywhere.

Usage:
  axis                          # Interactive chat
  axis "ask anything"           # One-shot query
  axis --scrape URL [FOLDER]    # Scrape URL
  axis --help                   # Help

Slash commands (in chat or one-shot):
  /scrape <url> [folder]        # Scrape a URL
  /search <query>               # Web search
  /run <command>                # Run shell command
  /read <file>                  # Read file into context
  /save [file]                  # Save last response
  /clear                        # Clear memory
  /history                      # Show session history
  /models                       # List available models
  /model <name>                 # Switch model
  /help                         # Show all commands
"""

import os, sys, json, time, uuid, re, subprocess, shutil
import urllib.request, urllib.parse
from pathlib import Path
from textwrap import fill

# â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AMALLO_URL   = os.environ.get('AMALLO_URL', 'https://axismundi.fun')
KEY_FILE     = Path.home() / '.config/amallo/key'
HISTORY_FILE = Path.home() / '.local/share/amallo/axis-history.jsonl'
SESSION_FILE = Path.home() / '.local/share/amallo/axis-session.json'
MODEL        = os.environ.get('AXIS_MODEL', 'dolphin-mistral:latest')

MODEL_ALIASES = {
    'dolphin':    'dolphin-mistral:latest',
    'mistral':    'dolphin-mistral:latest',
    'glm':        'glm4:latest',
    'glm4':       'glm4:latest',
    'default':    'dolphin-mistral:latest',
    # diffusion paradigm
    'diffusion':  'GSAI-ML/LLaDA-8B-Instruct',
    'llada':      'GSAI-ML/LLaDA-8B-Instruct',
    'llada2':     'inclusionAI/LLaDA2.1-mini',
    # brain router â€” use this to auto-route across all paradigms
    'brain':      'brain',
    'auto':       'brain',
}
# Brain router runs locally on port 8100 â€” overrides AMALLO_URL when model=brain
BRAIN_URL = os.environ.get('BRAIN_URL', 'http://localhost:8100')
DIFFUSION_URL = os.environ.get('DIFFUSION_URL', 'http://localhost:8200')
VERSION      = '1.0.0'
MAX_CONTEXT  = 12  # messages to keep in memory

# â”€â”€ COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class C:
    RESET  = '\033[0m'
    BOLD   = '\033[1m'
    DIM    = '\033[2m'
    GREEN  = '\033[0;32m'
    BLUE   = '\033[0;34m'
    PURPLE = '\033[0;35m'
    CYAN   = '\033[0;36m'
    ORANGE = '\033[0;33m'
    RED    = '\033[0;31m'
    GRAY   = '\033[0;90m'

def c(color, text): return f"{color}{text}{C.RESET}"
def ok(msg):  print(c(C.GREEN,  f"âœ“ {msg}"))
def err(msg): print(c(C.RED,    f"âœ— {msg}"), file=sys.stderr)
def info(msg): print(c(C.CYAN,  f"  {msg}"))
def dim(msg): print(c(C.DIM,    f"  {msg}"))

# â”€â”€ API KEY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_key():
    if KEY_FILE.exists():
        return KEY_FILE.read_text().strip()
    # Auto-create key
    print(c(C.ORANGE, "No API key found. Creating one..."))
    try:
        data = json.dumps({'identity': os.environ.get('USER','user'), 'role':'user'}).encode()
        req = urllib.request.Request(f'{AMALLO_URL}/amallo/keys/create', data=data,
                                     headers={'Content-Type':'application/json'})
        with urllib.request.urlopen(req, timeout=10) as r:
            resp = json.loads(r.read())
            key = resp['key']
            KEY_FILE.parent.mkdir(parents=True, exist_ok=True)
            KEY_FILE.write_text(key)
            KEY_FILE.chmod(0o600)
            ok(f"Created key: {key}")
            return key
    except Exception as e:
        err(f"Could not create key: {e}")
        sys.exit(1)

# â”€â”€ MEMORY / SESSION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def load_session():
    if SESSION_FILE.exists():
        try:
            return json.loads(SESSION_FILE.read_text())
        except:
            pass
    return {'messages': [], 'model': MODEL, 'id': uuid.uuid4().hex[:8]}

def save_session(session):
    SESSION_FILE.parent.mkdir(parents=True, exist_ok=True)
    SESSION_FILE.write_text(json.dumps(session))

def log_history(role, content):
    HISTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(HISTORY_FILE, 'a') as f:
        f.write(json.dumps({'ts': int(time.time()), 'role': role, 'content': content}) + '\n')

def trim_context(messages):
    # Keep system message + last N messages
    sys_msgs = [m for m in messages if m.get('role') == 'system']
    other    = [m for m in messages if m.get('role') != 'system']
    return sys_msgs + other[-MAX_CONTEXT:]

# â”€â”€ AI CALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def ask_ai(messages, model=None, max_tokens=1024):
    key = get_key()
    mdl = model or MODEL
    mdl = MODEL_ALIASES.get(mdl, mdl)  # resolve alias

    # Route to correct backend based on model
    if mdl in ('brain',):
        endpoint = f'{BRAIN_URL}/v1/chat/completions'
    elif mdl.startswith('GSAI-ML/') or mdl.startswith('inclusionAI/LLaDA'):
        endpoint = f'{DIFFUSION_URL}/v1/chat/completions'
    else:
        endpoint = f'{AMALLO_URL}/v1/chat/completions'

    try:
        data = json.dumps({
            'model': mdl,
            'messages': messages,
            'max_tokens': max_tokens,
            'temperature': 0.7
        }).encode()
        req = urllib.request.Request(
            endpoint, data=data,
            headers={'Authorization': f'Bearer {key}', 'Content-Type': 'application/json'})
        with urllib.request.urlopen(req, timeout=60) as r:
            resp = json.loads(r.read())
            content = resp['choices'][0]['message']['content']
            # Clean artifacts + Amallo-specific noise
            content = re.sub(r'<\|end of response\|>', '', content)
            content = re.sub(r'\[No inference backend available.*?\]', '[Amallo: model not loaded]', content)
            return content.strip()
    except urllib.error.URLError:
        err("Cannot reach Amallo. Check connection or run local server.")
        sys.exit(1)
    except Exception as e:
        err(f"API error: {e}")
        return None

# â”€â”€ SCRAPER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def scrape(url, folder=None, session=None):
    print(c(C.CYAN, f"ðŸ•·  Scraping: {url}"))

    # Fetch raw content
    try:
        req = urllib.request.Request(url, headers={
            'User-Agent': 'Mozilla/5.0 (axis/1.0; sovereign-scraper)'
        })
        with urllib.request.urlopen(req, timeout=30) as r:
            raw = r.read()
            content_type = r.headers.get('Content-Type','')
    except Exception as e:
        err(f"Fetch failed: {e}")
        return None

    # Extract text
    try:
        html = raw.decode('utf-8', errors='ignore')
    except:
        html = raw.decode('latin-1', errors='ignore')

    # Strip HTML tags â†’ clean text
    text = re.sub(r'<script[^>]*>.*?</script>', '', html, flags=re.DOTALL|re.IGNORECASE)
    text = re.sub(r'<style[^>]*>.*?</style>',  '', text,  flags=re.DOTALL|re.IGNORECASE)
    text = re.sub(r'<[^>]+>', ' ', text)
    text = re.sub(r'&nbsp;', ' ', text)
    text = re.sub(r'&amp;',  '&', text)
    text = re.sub(r'&lt;',   '<', text)
    text = re.sub(r'&gt;',   '>', text)
    text = re.sub(r'\s+',    ' ', text).strip()

    # Get title
    title_match = re.search(r'<title[^>]*>(.*?)</title>', html, re.IGNORECASE|re.DOTALL)
    title = re.sub(r'\s+', ' ', title_match.group(1)).strip() if title_match else url

    ok(f"Fetched: {title[:60]}")
    info(f"Content: {len(text):,} chars")

    # Save to folder
    saved_path = None
    if folder:
        dest = Path(folder)
        dest.mkdir(parents=True, exist_ok=True)
        # Sanitize filename from URL
        slug = re.sub(r'[^a-zA-Z0-9]+', '-', urllib.parse.urlparse(url).path)
        slug = slug.strip('-') or 'index'
        ts   = int(time.time())
        # Save raw HTML
        html_file = dest / f"{slug}-{ts}.html"
        html_file.write_text(html)
        # Save clean text
        txt_file = dest / f"{slug}-{ts}.txt"
        txt_file.write_text(f"URL: {url}\nTitle: {title}\n\n{text}")
        saved_path = str(txt_file)
        ok(f"Saved: {txt_file}")
        ok(f"HTML:  {html_file}")

    # AI summary
    print(c(C.BLUE, "\nðŸ“‹ Summarizing..."))
    preview = text[:3000]
    msgs = [{
        'role': 'user',
        'content': f'Summarize this webpage content concisely. URL: {url}\nTitle: {title}\n\nContent:\n{preview}'
    }]
    summary = ask_ai(msgs, max_tokens=400)
    if summary:
        print()
        print(c(C.BOLD, "Summary:"))
        for line in summary.split('\n'):
            print(f"  {line}")

    # Add to session context
    if session is not None:
        context_snippet = text[:2000]
        session['messages'].append({
            'role': 'user',
            'content': f'[Scraped {url}]\n{context_snippet}'
        })
        session['messages'].append({
            'role': 'assistant',
            'content': summary or 'Scraped content added to context.'
        })
        session['messages'] = trim_context(session['messages'])
        save_session(session)
        dim("(Content added to chat memory - you can now ask questions about it)")

    return summary

# â”€â”€ SLASH COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
COMMANDS = {}

def command(name, aliases=(), usage='', desc=''):
    def decorator(fn):
        COMMANDS[name] = {'fn': fn, 'usage': usage, 'desc': desc}
        for a in aliases:
            COMMANDS[a] = COMMANDS[name]
        return fn
    return decorator

@command('/scrape', aliases=('/sc',),
         usage='/scrape <url> [folder]',
         desc='Scrape a URL, summarize it, save to folder, add to memory')
def cmd_scrape(args, session):
    parts = args.strip().split()
    if not parts:
        url = input(c(C.ORANGE, "URL to scrape: ")).strip()
        if not url: return "Cancelled."
        parts = [url]
    url = parts[0]
    if not url.startswith('http'):
        url = 'https://' + url
    folder = parts[1] if len(parts) > 1 else None
    scrape(url, folder, session)

@command('/run', aliases=('/!', '/exec'),
         usage='/run <bash command>',
         desc='Run a shell command and add output to context')
def cmd_run(args, session):
    if not args.strip():
        args = input(c(C.ORANGE, "Command to run: ")).strip()
    print(c(C.DIM, f"$ {args}"))
    try:
        result = subprocess.run(args, shell=True, capture_output=True, text=True, timeout=30)
        output = (result.stdout + result.stderr).strip()
        print(output)
        # Add to context
        session['messages'].append({'role':'user',    'content': f'[Command: {args}]\n{output}'})
        session['messages'].append({'role':'assistant','content': 'Command output added to context.'})
        session['messages'] = trim_context(session['messages'])
        save_session(session)
    except Exception as e:
        err(str(e))

@command('/read', aliases=('/r',),
         usage='/read <file>',
         desc='Read a file and add its content to memory')
def cmd_read(args, session):
    path = args.strip()
    if not path:
        path = input(c(C.ORANGE, "File to read: ")).strip()
    try:
        content = Path(path).read_text()
        info(f"Read {len(content):,} chars from {path}")
        session['messages'].append({'role':'user',     'content': f'[File: {path}]\n{content[:4000]}'})
        session['messages'].append({'role':'assistant','content': f'File {path} loaded into context.'})
        session['messages'] = trim_context(session['messages'])
        save_session(session)
        ok("Added to memory")
    except Exception as e:
        err(str(e))

@command('/save', aliases=('/s',),
         usage='/save [filename]',
         desc='Save last AI response to a file')
def cmd_save(args, session):
    msgs = [m for m in session['messages'] if m['role'] == 'assistant']
    if not msgs:
        err("No AI response to save yet.")
        return
    content = msgs[-1]['content']
    path = args.strip() or f"axis-save-{int(time.time())}.txt"
    Path(path).write_text(content)
    ok(f"Saved to {path}")

@command('/model', aliases=('/m',),
         usage='/model <name>',
         desc='Switch AI model (qwen, glm4, dolphin, nano)')
def cmd_model(args, session):
    global MODEL
    name = args.strip()
    if not name:
        print(c(C.BOLD, f"Current model: {session.get('model', MODEL)}"))
        # List available
        key = get_key()
        req = urllib.request.Request(f'{AMALLO_URL}/v1/models',
                                     headers={'Authorization': f'Bearer {key}'})
        with urllib.request.urlopen(req, timeout=10) as r:
            models = json.loads(r.read())
            print(c(C.BOLD, "Available:"))
            for m in models.get('data', []):
                print(f"  â€¢ {m['id']}")
        return
    session['model'] = name
    MODEL = name
    save_session(session)
    ok(f"Switched to: {name}")

@command('/models', aliases=(),
         usage='/models',
         desc='List available models')
def cmd_models(args, session):
    cmd_model('', session)

@command('/chain', aliases=('/c',),
         usage='/chain',
         desc='Toggle chain mode: auto-run code from each AI response')
def cmd_chain(args, session):
    session['chain'] = not session.get('chain', False)
    state = session['chain']
    save_session(session)
    if state:
        print(c(C.PURPLE, "  â›“  CHAIN ON"))
        print(c(C.DIM,    "  On each response:"))
        print(c(C.DIM,    "    1. double Enter (clears any y/n gate)"))
        print(c(C.DIM,    "    2. extract code from response"))
        print(c(C.DIM,    "    3. paste + run it"))
        print(c(C.DIM,    "  /chain again or Ctrl+C to stop"))
    else:
        print(c(C.DIM, "  â›“  CHAIN OFF"))

@command('/clear', aliases=('/reset',),
         usage='/clear',
         desc='Clear conversation memory (start fresh)')
def cmd_clear(args, session):
    session['messages'] = []
    save_session(session)
    ok("Memory cleared")

@command('/history', aliases=('/h',),
         usage='/history [n]',
         desc='Show conversation history')
def cmd_history(args, session):
    n = int(args.strip()) if args.strip().isdigit() else 10
    msgs = session['messages'][-n:]
    if not msgs:
        dim("No history yet.")
        return
    for m in msgs:
        role = m['role']
        content = m['content'][:100] + '...' if len(m['content']) > 100 else m['content']
        color = C.GREEN if role == 'user' else C.BLUE
        print(c(color, f"{role}: ") + content)

@command('/help', aliases=('/?', '/commands'),
         usage='/help',
         desc='Show all commands')
def cmd_help(args, session):
    print()
    print(c(C.BOLD + C.PURPLE, "  axis commands"))
    print(c(C.DIM, "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))
    seen = set()
    for name, cmd in COMMANDS.items():
        if cmd['fn'] in seen: continue
        seen.add(cmd['fn'])
        print(f"  {c(C.CYAN, cmd['usage'].ljust(28))} {cmd['desc']}")
    print()
    print(c(C.DIM, "  Or just type anything â€” axis will figure it out."))
    print()

# â”€â”€ FILESYSTEM / PROCESS / CONFIG COMMANDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def cmd_ls(args, session):
    """List directory contents. Usage: /ls [path] [--depth N]"""
    parts = args.split() if args else ['.']
    depth = 2
    path = '.'
    i = 0
    while i < len(parts):
        if parts[i] == '--depth' and i+1 < len(parts):
            depth = int(parts[i+1]); i += 2
        else:
            path = parts[i]; i += 1
    path = os.path.expanduser(path)
    lines = []
    def walk(p, d):
        if d < 0: return
        try:
            entries = sorted(os.scandir(p), key=lambda e: (not e.is_dir(), e.name))
        except PermissionError:
            lines.append(f"[DENIED] {p}"); return
        for e in entries:
            prefix = '[DIR] ' if e.is_dir() else '[FILE]'
            lines.append(f"{prefix} {e.path}")
            if e.is_dir() and d > 0:
                walk(e.path, d-1)
    walk(path, depth-1)
    return '\n'.join(lines) or '(empty)'

def cmd_cat(args, session):
    """Read file contents. Usage: /cat <file> [--offset N] [--lines N]"""
    parts = args.split()
    path = offset = length = None
    i = 0
    while i < len(parts):
        if parts[i] == '--offset' and i+1 < len(parts):
            offset = int(parts[i+1]); i += 2
        elif parts[i] == '--lines' and i+1 < len(parts):
            length = int(parts[i+1]); i += 2
        else:
            path = parts[i]; i += 1
    if not path: return 'Usage: /cat <file> [--offset N] [--lines N]'
    path = os.path.expanduser(path)
    try:
        lines = open(path).readlines()
        start = offset or 0
        end = start + length if length else len(lines)
        numbered = [f"{start+i+1:4d} | {l.rstrip()}" for i, l in enumerate(lines[start:end])]
        return '\n'.join(numbered)
    except Exception as e:
        return f'Error: {e}'

def cmd_write(args, session):
    """Write content to file. Usage: /write <file> <content>"""
    parts = args.split(' ', 1)
    if len(parts) < 2: return 'Usage: /write <file> <content>'
    path = os.path.expanduser(parts[0])
    os.makedirs(os.path.dirname(path) or '.', exist_ok=True)
    open(path, 'w').write(parts[1])
    return f'Written: {path} ({len(parts[1])} chars)'

def cmd_mkdir(args, session):
    """Create directory. Usage: /mkdir <path>"""
    path = os.path.expanduser(args.strip())
    os.makedirs(path, exist_ok=True)
    return f'Created: {path}'

def cmd_mv(args, session):
    """Move/rename file. Usage: /mv <src> <dst>"""
    parts = args.split()
    if len(parts) != 2: return 'Usage: /mv <src> <dst>'
    shutil.move(os.path.expanduser(parts[0]), os.path.expanduser(parts[1]))
    return f'Moved: {parts[0]} â†’ {parts[1]}'

def cmd_stat(args, session):
    """Get file metadata. Usage: /stat <path>"""
    path = os.path.expanduser(args.strip())
    try:
        s = os.stat(path)
        is_dir = os.path.isdir(path)
        info_d = {
            'path': path,
            'type': 'directory' if is_dir else 'file',
            'size': s.st_size,
            'created': time.ctime(s.st_ctime),
            'modified': time.ctime(s.st_mtime),
            'permissions': oct(s.st_mode)[-4:],
        }
        if not is_dir:
            try:
                with open(path) as f:
                    lns = f.readlines()
                info_d['lineCount'] = len(lns)
                info_d['lastLine'] = len(lns) - 1
            except: pass
        return '\n'.join(f'{k}: {v}' for k,v in info_d.items())
    except Exception as e:
        return f'Error: {e}'

def cmd_find(args, session):
    """Search for files. Usage: /find <pattern> [path]"""
    parts = args.split()
    if not parts: return 'Usage: /find <pattern> [path]'
    pattern = parts[0]
    path = parts[1] if len(parts) > 1 else '.'
    result = subprocess.run(['find', path, '-name', f'*{pattern}*', '-not', '-path', '*/.*'],
                           capture_output=True, text=True, timeout=10)
    return result.stdout.strip() or 'No results'

def cmd_grep(args, session):
    """Search file contents. Usage: /grep <pattern> [path]"""
    parts = args.split(' ', 1)
    if not parts: return 'Usage: /grep <pattern> [path]'
    pattern = parts[0]
    path = parts[1].strip() if len(parts) > 1 else '.'
    result = subprocess.run(['rg', '--no-heading', '-n', pattern, path],
                           capture_output=True, text=True, timeout=10)
    if result.returncode != 0:
        result = subprocess.run(['grep', '-rn', pattern, path],
                               capture_output=True, text=True, timeout=10)
    out = result.stdout.strip()
    lines = out.split('\n')
    return '\n'.join(lines[:50]) + (f'\n... ({len(lines)-50} more)' if len(lines) > 50 else '') if out else 'No matches'

def cmd_ps(args, session):
    """List running processes. Usage: /ps [filter]"""
    result = subprocess.run(['ps', 'aux', '--sort=-%cpu'],
                           capture_output=True, text=True)
    lines = result.stdout.strip().split('\n')
    header = lines[0]
    procs = lines[1:]
    if args.strip():
        procs = [p for p in procs if args.strip().lower() in p.lower()]
    out = [header] + procs[:30]
    return '\n'.join(out)

def cmd_kill(args, session):
    """Kill process by PID. Usage: /kill <pid>"""
    import signal
    try:
        pid = int(args.strip())
        os.kill(pid, signal.SIGTERM)
        return f'Sent SIGTERM to PID {pid}'
    except Exception as e:
        return f'Error: {e}'

# Persistent process sessions
_PROCS = {}

def cmd_proc(args, session):
    """Start a persistent process session. Usage: /proc <command>"""
    if not args.strip(): return 'Usage: /proc <command>'
    pid_key = uuid.uuid4().hex[:8]
    proc = subprocess.Popen(
        args.strip(), shell=True, stdin=subprocess.PIPE,
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1
    )
    _PROCS[pid_key] = proc
    return f'Started session [{pid_key}] PID={proc.pid}\nUse: /send {pid_key} <input>\n     /output {pid_key}\n     /kill-session {pid_key}'

def cmd_send(args, session):
    """Send input to a process session. Usage: /send <session_id> <input>"""
    import fcntl, select
    parts = args.split(' ', 1)
    if len(parts) < 2: return 'Usage: /send <session_id> <input>'
    sid, inp = parts
    proc = _PROCS.get(sid)
    if not proc: return f'No session: {sid}'
    try:
        proc.stdin.write(inp + '\n'); proc.stdin.flush()
        time.sleep(0.3)
        output = []
        flags = fcntl.fcntl(proc.stdout, fcntl.F_GETFL)
        fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)
        try:
            while True:
                line = proc.stdout.readline()
                if not line: break
                output.append(line.rstrip())
        except: pass
        fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags)
        return '\n'.join(output) if output else '(no output yet â€” use /output <sid>)'
    except Exception as e:
        return f'Error: {e}'

def cmd_output(args, session):
    """Read output from process session. Usage: /output <session_id>"""
    import fcntl
    sid = args.strip()
    proc = _PROCS.get(sid)
    if not proc: return f'No session: {sid}'
    output = []
    flags = fcntl.fcntl(proc.stdout, fcntl.F_GETFL)
    fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    try:
        while True:
            line = proc.stdout.readline()
            if not line: break
            output.append(line.rstrip())
    except: pass
    fcntl.fcntl(proc.stdout, fcntl.F_SETFL, flags)
    return '\n'.join(output) if output else '(no new output)'

def cmd_sessions(args, session):
    """List active process sessions. Usage: /sessions"""
    if not _PROCS: return 'No active sessions'
    lines = []
    for sid, proc in list(_PROCS.items()):
        alive = proc.poll() is None
        status = 'running' if alive else f'exited({proc.returncode})'
        lines.append(f'[{sid}] PID={proc.pid} {status}')
        if not alive: del _PROCS[sid]
    return '\n'.join(lines)

def cmd_config(args, session):
    """Get/set axis config. Usage: /config [key] [value]"""
    config_path = Path.home() / '.config/amallo/axis-config.json'
    config_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        cfg = json.loads(config_path.read_text())
    except:
        cfg = {'amallo_url': AMALLO_URL, 'model': MODEL, 'allowed_dirs': [str(Path.home())]}

    parts = args.strip().split(' ', 1) if args.strip() else []
    if not parts:
        return json.dumps(cfg, indent=2)
    elif len(parts) == 1:
        return str(cfg.get(parts[0], f'Key not found: {parts[0]}'))
    else:
        key, val = parts
        try: val = json.loads(val)
        except: pass
        cfg[key] = val
        config_path.write_text(json.dumps(cfg, indent=2))
        return f'Set {key} = {val}'

# Register new commands in COMMANDS dict
_new_cmds = [
    ('/ls',       'List directory contents',       '/ls [path] [--depth N]',         cmd_ls),
    ('/cat',      'Read file contents',             '/cat <file> [--offset N] [--lines N]', cmd_cat),
    ('/write',    'Write file',                     '/write <file> <content>',        cmd_write),
    ('/mkdir',    'Create directory',               '/mkdir <path>',                  cmd_mkdir),
    ('/mv',       'Move/rename file',               '/mv <src> <dst>',                cmd_mv),
    ('/stat',     'File metadata',                  '/stat <path>',                   cmd_stat),
    ('/find',     'Find files by name',             '/find <pattern> [path]',         cmd_find),
    ('/grep',     'Search file contents',           '/grep <pattern> [path]',         cmd_grep),
    ('/ps',       'List processes',                 '/ps [filter]',                   cmd_ps),
    ('/kill',     'Kill process by PID',            '/kill <pid>',                    cmd_kill),
    ('/proc',     'Start process session',          '/proc <command>',                cmd_proc),
    ('/send',     'Send input to process session',  '/send <session_id> <input>',     cmd_send),
    ('/output',   'Read process session output',    '/output <session_id>',           cmd_output),
    ('/sessions', 'List active process sessions',   '/sessions',                      cmd_sessions),
    ('/config',   'Get/set axis config',            '/config [key] [value]',          cmd_config),
]
for _name, _desc, _usage, _fn in _new_cmds:
    COMMANDS[_name] = {'fn': _fn, 'usage': _usage, 'desc': _desc}

# â”€â”€ DISPATCH SLASH COMMAND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def dispatch(text, session):
    """Handle slash command or pass to AI."""
    text = text.strip()
    if not text: return

    # Parse slash command
    if text.startswith('/'):
        parts = text.split(None, 1)
        name  = parts[0].lower()
        args  = parts[1] if len(parts) > 1 else ''

        if name in COMMANDS:
            return COMMANDS[name]['fn'](args, session)
        else:
            # Unknown command - let AI figure it out
            print(c(C.DIM, f"Unknown command '{name}'. Asking AI..."))
            intent_msg = [{
                'role': 'system',
                'content': (
                    'You are axis, a sovereign AI CLI. The user typed an unknown slash command. '
                    'Try to understand what they want and do it, or ask them one clarifying question.'
                )
            }, {'role': 'user', 'content': text}]
            reply = ask_ai(intent_msg, max_tokens=300)
            if reply:
                print()
                print_response(reply)
                session['messages'].append({'role':'user',      'content': text})
                session['messages'].append({'role':'assistant', 'content': reply})
                save_session(session)
            return

    # Regular message - send to AI
    session['messages'].append({'role': 'user', 'content': text})
    session['messages'] = trim_context(session['messages'])
    log_history('user', text)

    print(c(C.DIM, "..."), end='\r')
    reply = ask_ai(session['messages'], model=session.get('model', MODEL))

    if reply:
        print(' ' * 10, end='\r')
        print()
        print_response(reply)
        print()
        session['messages'].append({'role': 'assistant', 'content': reply})
        session['messages'] = trim_context(session['messages'])
        log_history('assistant', reply)
        save_session(session)
        return reply   # caller (repl) uses this for chain mode

def print_response(text):
    """Pretty-print AI response."""
    width = min(shutil.get_terminal_size().columns - 4, 80)
    for line in text.split('\n'):
        if line.startswith('```'):
            print(c(C.DIM, '  ' + line))
        elif line.startswith('#'):
            print(c(C.BOLD, '  ' + line))
        elif line.startswith('- ') or line.startswith('* '):
            print(c(C.CYAN, '  â€¢') + ' ' + line[2:])
        else:
            if len(line) > width:
                wrapped = fill(line, width=width)
                for wl in wrapped.split('\n'):
                    print('  ' + wl)
            else:
                print('  ' + line)

def extract_code(text):
    """Pull the first code block out of a response, or return full text."""
    # fenced code block: ```lang\n...code...\n```
    m = re.search(r'```(?:\w+)?\n?([\s\S]*?)```', text)
    if m:
        return m.group(1).strip()
    # single backtick inline and barely any other text
    m = re.search(r'`([^`]+)`', text)
    if m and len(re.sub(r'`[^`]+`', '', text).strip()) < 20:
        return m.group(1).strip()
    return text.strip()

# â”€â”€ MCP SERVER MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MCP_TOOLS = [
    {"name": "read_file", "description": "Read file contents", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}, "offset": {"type": "number"}, "length": {"type": "number"}}, "required": ["path"]}},
    {"name": "write_file", "description": "Write file contents", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}, "content": {"type": "string"}}, "required": ["path", "content"]}},
    {"name": "list_directory", "description": "List directory", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}, "depth": {"type": "number"}}, "required": ["path"]}},
    {"name": "create_directory", "description": "Create directory", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}}, "required": ["path"]}},
    {"name": "move_file", "description": "Move/rename file", "inputSchema": {"type": "object", "properties": {"source": {"type": "string"}, "destination": {"type": "string"}}, "required": ["source", "destination"]}},
    {"name": "get_file_info", "description": "File metadata", "inputSchema": {"type": "object", "properties": {"path": {"type": "string"}}, "required": ["path"]}},
    {"name": "start_search", "description": "Search for files or content", "inputSchema": {"type": "object", "properties": {"pattern": {"type": "string"}, "path": {"type": "string"}, "type": {"type": "string", "enum": ["file", "content"]}}, "required": ["pattern"]}},
    {"name": "list_processes", "description": "List running processes", "inputSchema": {"type": "object", "properties": {"filter": {"type": "string"}}}},
    {"name": "kill_process", "description": "Kill process by PID", "inputSchema": {"type": "object", "properties": {"pid": {"type": "number"}}, "required": ["pid"]}},
    {"name": "start_process", "description": "Start a terminal process", "inputSchema": {"type": "object", "properties": {"command": {"type": "string"}}, "required": ["command"]}},
    {"name": "interact_with_process", "description": "Send input to process", "inputSchema": {"type": "object", "properties": {"pid": {"type": "string"}, "input": {"type": "string"}}, "required": ["pid", "input"]}},
    {"name": "read_process_output", "description": "Read process output", "inputSchema": {"type": "object", "properties": {"pid": {"type": "string"}}, "required": ["pid"]}},
    {"name": "list_sessions", "description": "List terminal sessions", "inputSchema": {"type": "object", "properties": {}}},
    {"name": "execute_command", "description": "Execute shell command", "inputSchema": {"type": "object", "properties": {"command": {"type": "string"}}, "required": ["command"]}},
    {"name": "get_config", "description": "Get axis configuration", "inputSchema": {"type": "object", "properties": {}}},
    {"name": "set_config_value", "description": "Set config value", "inputSchema": {"type": "object", "properties": {"key": {"type": "string"}, "value": {}}, "required": ["key", "value"]}},
    {"name": "chat", "description": "Chat with AI via amallo-brain", "inputSchema": {"type": "object", "properties": {"message": {"type": "string"}, "model": {"type": "string"}}, "required": ["message"]}},
    {"name": "operate", "description": "Operate the browser (Kernel Mustard)", "inputSchema": {"type": "object", "properties": {"command": {"type": "string"}}, "required": ["command"]}},
]

def mcp_tool_call(name, args):
    """Dispatch an MCP tool call to the appropriate axis function."""
    dummy_session = {}
    tool_map = {
        'read_file':           lambda a: cmd_cat(f"{a['path']}" + (f" --offset {a['offset']}" if 'offset' in a else '') + (f" --lines {a['length']}" if 'length' in a else ''), dummy_session),
        'write_file':          lambda a: cmd_write(f"{a['path']} {a['content']}", dummy_session),
        'list_directory':      lambda a: cmd_ls(f"{a['path']}" + (f" --depth {a['depth']}" if 'depth' in a else ''), dummy_session),
        'create_directory':    lambda a: cmd_mkdir(a['path'], dummy_session),
        'move_file':           lambda a: cmd_mv(f"{a['source']} {a['destination']}", dummy_session),
        'get_file_info':       lambda a: cmd_stat(a['path'], dummy_session),
        'start_search':        lambda a: cmd_find(f"{a['pattern']} {a.get('path','.')}", dummy_session) if a.get('type') != 'content' else cmd_grep(f"{a['pattern']} {a.get('path','.')}", dummy_session),
        'list_processes':      lambda a: cmd_ps(a.get('filter',''), dummy_session),
        'kill_process':        lambda a: cmd_kill(str(a['pid']), dummy_session),
        'start_process':       lambda a: cmd_proc(a['command'], dummy_session),
        'interact_with_process': lambda a: cmd_send(f"{a['pid']} {a['input']}", dummy_session),
        'read_process_output': lambda a: cmd_output(a['pid'], dummy_session),
        'list_sessions':       lambda a: cmd_sessions('', dummy_session),
        'execute_command':     lambda a: cmd_run(a['command'], dummy_session),
        'get_config':          lambda a: cmd_config('', dummy_session),
        'set_config_value':    lambda a: cmd_config(f"{a['key']} {json.dumps(a['value'])}", dummy_session),
        'chat':                lambda a: ask_ai([{'role': 'user', 'content': a['message']}], model=a.get('model', MODEL)),
        'operate':             lambda a: urllib.request.urlopen(
            urllib.request.Request(
                'http://localhost:8600/api/command',
                data=json.dumps({'cmd': a['command']}).encode(),
                headers={'Content-Type': 'application/json'}
            )
        ).read().decode(),
    }
    fn = tool_map.get(name)
    if not fn: return f'Unknown tool: {name}'
    try:
        return fn(args)
    except Exception as e:
        return f'Error: {e}'

def mcp_server():
    """
    Run axis as an MCP (Model Context Protocol) JSON-RPC 2.0 server over stdio.
    Compatible with Claude Desktop, Cursor, Zed, and any MCP client.

    Add to Claude Desktop config (~/.config/claude/claude_desktop_config.json):
    {
      "mcpServers": {
        "axis": {
          "command": "axis",
          "args": ["--mcp"]
        }
      }
    }
    """
    def send(obj):
        sys.stdout.write(json.dumps(obj) + '\n')
        sys.stdout.flush()

    while True:
        try:
            line = sys.stdin.readline()
            if not line: break
            req = json.loads(line.strip())
        except (json.JSONDecodeError, EOFError):
            continue

        method  = req.get('method', '')
        req_id  = req.get('id')
        params  = req.get('params', {})

        if method == 'initialize':
            send({"jsonrpc": "2.0", "id": req_id, "result": {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}},
                "serverInfo": {
                    "name": "axis",
                    "version": "2.0",
                    "description": "Sovereign AI CLI â€” un-ownable, self-hosted, zero cloud"
                }
            }})

        elif method == 'tools/list':
            send({"jsonrpc": "2.0", "id": req_id, "result": {"tools": MCP_TOOLS}})

        elif method == 'tools/call':
            tool_name = params.get('name', '')
            tool_args = params.get('arguments', {})
            result    = mcp_tool_call(tool_name, tool_args)
            send({"jsonrpc": "2.0", "id": req_id, "result": {
                "content": [{"type": "text", "text": str(result)}],
                "isError": False
            }})

        elif method == 'notifications/initialized':
            pass  # no response needed

        else:
            if req_id is not None:
                send({"jsonrpc": "2.0", "id": req_id, "error": {
                    "code": -32601, "message": f"Method not found: {method}"
                }})

# â”€â”€ INTERACTIVE CHAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def repl(session):
    """Interactive chat mode."""
    model = session.get('model', MODEL)
    print(c(C.PURPLE, f"\n  axis {VERSION}  ") + c(C.DIM, f"model:{model}  /help for commands"))
    print(c(C.DIM, "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))
    print()

    while True:
        try:
            text = input(c(C.GREEN, 'you > ')).strip()
            if not text: continue
            if text.lower() in ('exit', 'quit', 'bye', '/exit', '/quit'):
                print(c(C.DIM, "  bye"))
                break

            reply = dispatch(text, session)

            # â”€â”€ CHAIN MODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # After every AI response, if chain is ON:
            #   step 1: double Enter (y) â€” clears any y/n gate silently
            #   step 2: extract code from response
            #   step 3: paste it back as next input and run it
            while reply and session.get('chain'):
                code = extract_code(reply)
                # step 1: two silent 'y' dispatches for confirmation gates
                dispatch('y', session)
                dispatch('y', session)
                # step 2+3: run the extracted code as next prompt
                print(c(C.PURPLE, f"  â›“  chaining: ") + c(C.DIM, code[:80]))
                reply = dispatch(code, session)

        except KeyboardInterrupt:
            print()
            if session.get('chain'):
                session['chain'] = False
                save_session(session)
                print(c(C.DIM, "  â›“  chain stopped"))
            else:
                print(c(C.DIM, "  (Ctrl+C â€” type 'exit' to quit)"))
        except EOFError:
            print()
            break

# â”€â”€ ENTRY POINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    args = sys.argv[1:]
    session = load_session()

    # No args â†’ interactive
    if not args:
        repl(session)
        return

    # Parse --flags
    if args[0] in ('--help', '-h'):
        print(__doc__)
        return

    if args[0] == '--mcp':
        mcp_server()
        return

    if args[0] in ('--version', '-v'):
        print(f"axis {VERSION}")
        return

    if args[0] in ('--scrape', '--amalloscrape'):
        url    = args[1] if len(args) > 1 else input("URL: ").strip()
        folder = args[2] if len(args) > 2 else None
        if not url.startswith('http'): url = 'https://' + url
        scrape(url, folder, session)
        return

    if args[0] == '--clear':
        session['messages'] = []
        save_session(session)
        ok("Memory cleared")
        return

    if args[0] == '--history':
        n = int(args[1]) if len(args) > 1 else 10
        cmd_history(str(n), session)
        return

    if args[0] == '--model':
        if len(args) > 1:
            cmd_model(args[1], session)
        else:
            cmd_model('', session)
        return

    # Everything else: one-shot query or slash command
    text = ' '.join(args)

    # Check if it looks like a question/task
    if not text.startswith('/') and not text.startswith('--'):
        # One-shot query
        session['messages'].append({'role': 'user', 'content': text})
        session['messages'] = trim_context(session['messages'])
        log_history('user', text)

        reply = ask_ai(session['messages'], model=session.get('model', MODEL))
        if reply:
            print_response(reply)
            print()
            session['messages'].append({'role': 'assistant', 'content': reply})
            save_session(session)
    else:
        dispatch(text, session)

if __name__ == '__main__':
    main()
